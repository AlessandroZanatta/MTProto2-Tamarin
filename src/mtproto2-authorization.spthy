/*
 * MTProto 2.0: Creating an authorization key.
 *
 * Model for the protocol used to create long-term keys shared 
 * between a client and Telegram's server.
 *
 * See: https://core.telegram.org/mtproto/auth_key
 */

/*****************************************************************/
/* Decomposition into prime factors.                             */
/*                                                               */
/* This is used only for proof-of-work, a measure against DoS,   */
/* which we do not include in our threat model.                  */
/* This definition is reported here for the sake of              */
/* completeness, but it is never used.                           */
/*****************************************************************/

  functions:
    /*
     * Arguments:
     *  - a prime
     *  - another prime
     *
     * Outputs: their multiplication
     */
    multiply/2,
    /*
     * Arguments:
     *  - the multiplication of two primes
     *
     * Outputs: the two primes
     */
    factorise/1

  equations:
    factorise(multiply(x, y)) = <x, y>

/*****************************************************************/
/* Messages exchanged during the authorization protocol          */
/*****************************************************************/

/*
 * Two public constants are used: 'FIXED_NS' and 'WEAK_NK'.
 * 
 * Both represents nonces. The first one represents a constant 
 * nonce that may be used by the server, the second represents
 * a weak (leakable) nonce which is supposed to be kept
 * secret and its sent by the client to the server (encrypted).
 */


/*****************************************************************/
/* Protocol exchange definition                                  */
/*****************************************************************/

/* 1. C -> S: Nc */
  rule Client_1 [color=#E2C290]:
      [ 
        Fr(~nc),

        /* 
         * Following the eCK model, generate ephemeral 
         * secrets and save them for revealing them later. 
         */
        Fr(~nk),
        Fr(~c) 
      ]
    --[
        /* 
         * A client starts a run of the authorization protocol with 
         * the server proposing a random nonce ~nc.
         */
        ClientStartsSession(~nc)
      ]->
      [ 
        ClientState_1(~nc, ~nk, ~c), 
        Out(~nc),
        !AuthProtClientEphemeralSecrets(~nk, ~c) 
      ]

  /* 2. S -> C: Nc, Ns, fpk(pkey) */
  rule Server_2 [color=#0088CC]:
      [ In(nc), !PrivateKey($Server, skey), NS(ns), Fr(~s) ]
    --[
        /*
         * Server has received a request to start a 
         * run of the authorization protocol with client nonce nc.
         */
        ServerReceivesRequest(nc),

        /*
         * Captures information about the randomness of the 
         * server nonce.
         *
         * Lemmas using this fact are supposed to check whetever
         * the second term (actual nonce) is equal to 'FIXED_NS'
         * or not.
         */
        ServerGeneratesNonce(ns)
      ]->
      [ 
        Out(<nc, ns, fpk(pk(skey))>), 
        ServerState_2(nc, ns, skey, ~s), 
        !AuthProtServerEphemeralSecrets(~s) 
      ]


  /* 3. C -> S: Nc, Ns, aenc(Nc, Ns, Nk){pkey} */
  rule Client_3 [color=#E2C290]:
      [ 
        ClientState_1(~nc, ~nk, ~c),
        In(<~nc, ns, fingerprint>),
        !PublicKey($Server, pkey, fingerprint)
      ]
    --[
        /*
         * Client X has obtained public key spkey corresponding
         * to the key fingerprint sent by server.
         */
        ClientGetsServerPublicKey(pkey),

        /*
         * Client X requests DH parameters to server by 
         * sending a secret nonce nk in the session identified 
         * by <nc, ns>.
         */
        ClientRequestsDHParameters(~nc, ns, ~nk)
      ]->
      [ 
        ClientState_3(~nc, ns, ~nk, pkey, ~c),
        Out(<~nc, ns, aenc(<~nc, ns, ~nk>, pkey)>)
      ]

  /* 4. S -> C: Nc, Ns, senc(Nc, Ns, Shalfkey){<Ns, Nk>} */
  rule Server_4 [color=#0088CC]:
    let
      half = 'g' ^ ~s
      key  = genKey(ns, nk)
      iv   = genIV(ns, nk)
    in
      [
        ServerState_2(nc, ns, skey, ~s),
        In(aenc(<nc, ns, nk>, pk(skey)))
      ]
    --[
        /* 
         * Server has accepted a request to generate an
         * authorization key in session <nc, ns> for a client
         * who has sent a secret nonce nk.
         */
        ServerAcceptsClient(nc, ns, nk),

        /*
         * Server sends DH parameter 'g' and its half-key g_a
         * to a client who has started session <nc, ns> and sent
         * secret nonce nk.
         */
        ServerSendsDHParameters(nc, ns, nk, half)
      ]->
      [
        ServerState_4(nc, ns, nk, skey, ~s),
        Out(<nc, ns, senc(<'StoC', nc, ns, half>, key, iv)>)
      ]

  /* 5. C -> S: Nc, Ns, senc(Nc, Ns, Chalfkey){<Ns, Nk>} */
  rule Client_5 [color=#E2C290]:
    let
      g_s        = 'g' ^ ~s
      key  = genKey(ns, ~nk)
      iv   = genIV(ns, ~nk)
      half       = 'g' ^ ~c
      shared_key = g_s ^ ~c
    in
      [
        ClientState_3(~nc, ns, ~nk, pkey, ~c),
        In(<~nc, ns, senc(<'StoC', ~nc, ns, g_s>, key, iv)>)
      ]
    --[
        /*
         * Client X has received DH paramters and the server's
         * half key g_s from server in the session identified by <nc, ns>
         * for which the client has generated secret nonce nk.
         */
        ClientReceivesDHParameters(~nc, ns, ~nk, g_s),

        /*
         * Client X has accepted the DH parameter received 
         * from server in session <nc, ns> for which the client has
         * generated secret nonce nk and received the server's half
         * key g_s.
         */
        ClientAcceptsDHParameters(~nc, ns, ~nk, g_s),

        /*
         * Client X completes the DH exchange with server in session 
         * <nc, ns> for which X has generate the secret nonce nk and has 
         * received DH parameters <p, g> and half key g_s by computing
         * the authorization key authKey and by sending its half key
         * g_b to the server.
         */
        ClientEndsDHExchange(~nc, ns, ~nk, g_s, ~c, shared_key),

        /*
         * Client X has negotiated the authorization key authKey with
         * server in session <nc, ns>.
         */
        ClientAcceptsAuthKey(~nc, ns, ~nk, shared_key)]->
      [
        ClientState_5(~nc, ns, ~nk, pkey, g_s, ~c, shared_key),
        Out(<~nc, ns, senc(<'CtoS', ~nc, ns, half>, key, iv)>),
        !AuthKeyClient($Server, shared_key)
      ]


  /* 6. S -> C: Nc, Ns, fpk(Nk, shared_key) */
  rule Server_6 [color=#0088CC]:
    let
      g_c        = 'g' ^ ~c
      key  = genKey(ns, nk)
      iv   = genIV(ns, nk)
      shared_key = g_c ^ ~s
    in
      [ 
        ServerState_4(nc, ns, nk, skey, ~s), 
        In(<nc, ns, senc(<'CtoS', nc, ns, g_c>, key, iv)>) 
      ]
    --[ 
        /*
         * Server completes the DH exchange with parameters <p, g>
         * in session <nc, ns> for which a client has generated
         * the secret nonce nk and the half key g_b by computing
         * the authorization key authKey.
         */
        ServerEndsDHExchange(nc, ns, nk, g_c, shared_key),

        /*
         * Server has negotiated the authorization key authKey with a 
         * client in session <nc, ns>.
         */
        ServerAcceptsAuthKey(nc, ns, nk, shared_key),
      
        /*
         * Server sends an acknowledgment to a client in session 
         * <nc, ns> for which the client has generated secret nonce nk.
         */
        ServerSendsAck(nc, ns, nk, shared_key)
      ]->
      [ 
        !AuthKeyServer(keyID(shared_key), shared_key), 
        Out(<nc, ns, hashNk(nk, shared_key)>),
        !ServerEndsProtocol(nc, ns, nk, shared_key, skey, ~s) 
      ]
  

  rule Client_7 [color=#E2C290]:
      [ 
        ClientState_5(~nc, ns, ~nk, pkey, g_s, ~c, shared_key),
        In(<~nc, ns, hashNk(~nk, shared_key)>)
      ]
    --[ 
        /*
         * Client X has received an acknowledgment from the server for
         * the authorization key negotiated in session <nc, ns>.
         */
        ClientReceivesAck(~nc, ns, ~nk, shared_key)
      ]->
      [ !ClientEndsProtocol(~nc, ns, ~nk, shared_key, ~c) ]
  

/*****************************************************************/
/* Key registration and Diffie Hellman parameters                */
/*****************************************************************/

  /* Register a public key for the server */
  rule RegisterPublicKey [color=#99C24D]:
    let
      pkey        = pk(~skey)
      fingerprint = fpk(pkey)
    in
      [ Fr(~skey) ]
    -->
      [ !PrivateKey($X, ~skey), !PublicKey($X, pkey, fingerprint), Out(pkey) ]
  
  rule GenerateRandomServerNonce [color=#99C24D]:
      [ Fr(~ns) ]
    -->
      [ NS(~ns) ]

  rule GenerateFixedServerNonce [color=#99C24D]:
      []
    -->
      [ NS('FIXED_NS') ]


/*****************************************************************/
/* Revealing of secret information                               */
/*****************************************************************/

  /* 
   * Allows the attacker to register an authorization key for 
   * itself with a server. 
   *
   * Note that the attacker is required to provide two fresh DH 
   * secret exponents. This is needed to restrict the range of 
   * possible "values" the shared key may assume.
   */
  rule RegisterSharedKey [color=#FE4A49]:
    let
      shared_key = 'g' ^ ~c ^ ~s
    in
      [ In(<~c, ~s>) ]
    --[ RegisteredSharedKey(shared_key) ]->
      [ !AuthKeyServer(keyID(shared_key), shared_key) ]

  /* Compromise shared key. */
  rule CompromiseSharedKey [color=#FE4A49]:
      [ 
        !AuthKeyClient($Server, shared_key),
        !AuthKeyServer(keyID(shared_key), shared_key)
      ]
    --[ CompromisedSharedKey(shared_key) ]->
      [ Out(shared_key) ]

  /* Reveals long-term secret of the server. */
  rule CompromisePrivateKey [color=#FE4A49]:
      [ !PrivateKey($Server, skey) ]
    --[ CompromisedPrivateKey(skey) ]->
      [ Out(skey) ]

  /* Reveals the secret client's nonce. */
  rule CompromiseNk [color=#FE4A49]:
      [ !AuthProtClientEphemeralSecrets(nk, b) ]
    --[ CompromisedNk(nk) ]->
      [ Out(nk) ]

  /* Reveals the client's DH secret exponent. */
  rule CompromiseAuthProtClientExponent [color=#FE4A49]:
      [ !AuthProtClientEphemeralSecrets(nk, c) ]
    --[ CompromisedClientExponent(c) ]->
      [ Out(c) ]

  /* Reveals all client's ephemeral secrets. */
  rule CompromiseClientEphemeralSecrets [color=#FE4A49]:
      [ !AuthProtClientEphemeralSecrets(nk, c) ]
    --[ CompromisedClientEphemeralSecrets(nk, c) ]->
      [ Out(<nk, c>) ]

  /* Reveals the client's DH secret exponent. */
  rule CompromiseAuthProtServerExponent [color=#FE4A49]:
      [ !AuthProtServerEphemeralSecrets(s) ]
    --[ CompromisedServerExponent(s) ]->
      [ Out(s) ]


/*****************************************************************/
/* Post-revealing of secret information                          */
/*****************************************************************/

  /* 
   * Reveals the private key of the server AFTER a 
   * successful protocol execution.
   */
  rule PostCompromisePrivateKey [color=#FE4A49]:
      [
        !ClientEndsProtocol(nc, ns, nk, shared_key, c),
        !ServerEndsProtocol(nc, ns, nk, shared_key, skey, s),
        !PrivateKey($Server, skey)
      ]
    --[ PostCompromisedPrivateKey(skey) ]->
      [ Out(skey) ]

  
  /* 
   * Reveals the secret nonce nk AFTER a 
   * successful protocol execution.
   */
  rule PostCompromiseNonce [color=#FE4A49]:
      [
        !ClientEndsProtocol(nc, ns, nk, shared_key, c),
        !ServerEndsProtocol(nc, ns, nk, shared_key, skey, s)
      ]
    --[ PostCompromisedNonce(nk) ]->
      [ Out(nk) ]


  /* 
   * Reveals the secret exponent of the client 
   * AFTER a successful protocol execution.
   */
  rule PostCompromiseClientExponent [color=#FE4A49]:
      [
        !ClientEndsProtocol(nc, ns, nk, shared_key, c),
        !ServerEndsProtocol(nc, ns, nk, shared_key, skey, s)
      ]
    --[ PostCompromisedClientExponent(c) ]->
      [ Out(c) ]


  /* 
   * Reveals the secret exponent of the server 
   * AFTER a successful protocol execution.
   */
  rule PostCompromiseServerExponent [color=#FE4A49]:
      [
        !ClientEndsProtocol(nc, ns, nk, shared_key, c),
        !ServerEndsProtocol(nc, ns, nk, shared_key, skey, s)
      ]
    --[ PostCompromisedServerExponent(s) ]->
      [ Out(s) ]
