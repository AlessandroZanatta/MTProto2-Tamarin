/*
 * MTProto 2.0: Creating an authorization key.
 *
 * Model for the protocol used to create long-term keys shared 
 * between a client and Telegram's server.
 *
 * See: https://core.telegram.org/mtproto/auth_key
 */

/*****************************************************************/
/* Decomposition into prime factors.                             */
/*                                                               */
/* This is used only for proof-of-work, a measure against DoS,   */
/* which we do not include in our threat model.                  */
/* This definition is reported here for the sake of              */
/* completeness, but it is never used.                           */
/*****************************************************************/

  functions:
    /*
     * Arguments:
     *  - a prime
     *  - another prime
     *
     * Outputs: their multiplication
     */
    multiply/2,
    /*
     * Arguments:
     *  - the multiplication of two primes
     *
     * Outputs: the two primes
     */
    factorise/1

  equations:
    factorise(multiply(x, y)) = <x, y>

/*****************************************************************/
/* Messages exchanged during the authorization protocol          */
/*****************************************************************/

/*
 * Two public constants are used: 'FIXED_NS' and 'WEAK_NK'.
 * 
 * Both represents nonces. The first one represents a constant 
 * nonce that may be used by the server, the second represents
 * a weak (leakable) nonce which is supposed to be kept
 * secret and its sent by the client to the server (encrypted).
 */


/*****************************************************************/
/* Protocol exchange definition                                  */
/*****************************************************************/

  /* 
   * 1. The client initiates a session to negotiate an 
   * authorization key.
   */
  rule ClientAuth_1 [color=#5feb34]:
      [
        /* Get identity of the principal. */
        Fr(~nc),
        Fr(~nk),
        Fr(~b)
      ]
    --[ 
        /* 
         * A client starts a run of the authorization protocol with 
         * the server proposing a random nonce ~nc.
         */
        ClientStartsSession(~nc)
      ]->
      [ 
        Out(~nc),

        /*
         * Store ephemeral secrets so that they can be revealed later.
         * This follows the eCK security model. 
         */
        !AuthProtClientEphemeralSecrets(~nk, ~b),
        ClientAuthState_1(~nc, ~nk, ~b)
      ]


  /*
   * 2. The server receives the client nonce and sends his nonce,
   * together with the public key fingerprint.
   */
  rule ServerAuth_2 [color=#3440eb]:
      [
        In(nc),

        /* Ephemeral secret (DH exponent) generation */
        Fr(~a),
        !RSAServerKey($Server, skey, pkey),

        NS(ns) 
      ]
    --[
        /*
         * Server $Server has received a request to start a 
         * run of the authorization protocol with client nonce nc.
         */
        ServerReceivesRequest(nc),

        /*
         * Captures information about the randomness of the 
         * server nonce.
         *
         * Lemmas using this fact are supposed to check whetever
         * the second term (actual nonce) is equal to 'FIXED_NS'
         * or not.
         */
        ServerGeneratesNonce(ns)
      ]->
      [
        Out(<nc, ns, fpk(pkey)>),
        !AuthProtServerEphemeralSecrets(~a),
        ServerAuthState_2(nc, ns, skey, pkey)
      ]


  /*
   * 3. Receive server nonce.
   */
  rule ClientAuth_3 [color=#5feb34]:
    let
      fp = fpk(spkey)
      encReqDHP = RSA_enc(<nc, ns, nk>, spkey)
    in
      [
        ClientAuthState_1(nc, nk, b),
        In(<nc, ns, fp>),
        !RSAPublicKey($Server, spkey, fp)
      ]
    --[
        /*
         * Client X has obtained public key spkey corresponding
         * to the key fingerprint sent by server.
         */
        ClientGetsServerPublicKey(spkey),

        /*
         * Client X requests DH parameters to server by 
         * sending a secret nonce nk in the session identified 
         * by <nc, ns>.
         */
        ClientRequestsDHParameters(nc, ns, nk) 
      ]->
      [
        Out(<nc, ns, encReqDHP>),
        ClientAuthState_4(nc, nk, b, ns, spkey)
      ]

  /*
   * 5. Answer to DH exchange.
   */
  rule ServerAuth_5 [color=#3440eb]:
    let
      encReqDHP = RSA_enc(<nc, ns, nk>, pkey)
      g_a       = 'g' ^ ~a
      key       = genKey(ns, nk)
      iv        = genIV(ns, nk)
      encAnswer = AES_IGE_enc(<'StoC', nc, ns, g_a>, key, iv)
    in
      [
        ServerAuthState_2(nc, ns, skey, pkey),
        In(<nc, ns, encReqDHP>),
        Fr(~a)
      ]
    --[
        /* 
         * Server has accepted a request to generate an
         * authorization key in session <nc, ns> for a client
         * who has sent a secret nonce nk.
         */
        ServerAcceptsClient(nc, ns, nk),

        /*
         * Server sends DH parameter 'g' and its half-key g_a
         * to a client who has started session <nc, ns> and sent
         * secret nonce nk.
         */
        ServerSendsDHParameters(nc, ns, nk, g_a)
      ]->
      [
        Out(<nc, ns, encAnswer>),
        ServerAuthState_5(nc, ns, skey, pkey, nk, ~a, g_a)
      ]


  /*
   * 6-7. Client receives server's half key and answers with his half key.
   */
  rule ClientAuth_6 [color=#5feb34]:
    let
      key         = genKey(ns, nk)
      iv          = genIV(ns, nk)
      encAuthMsg1 = AES_IGE_enc(<nc, ns, g_a>, key, iv)

      authKey     = g_a  ^ b
      g_b         = 'g'  ^ b
      encAuthMsg2 = AES_IGE_enc(<nc, ns, g_b>, key, iv) 
    in
      [
        ClientAuthState_4(nc, nk, b, ns, spkey),
        In(<nc, ns, encAuthMsg1>)
      ]
    --[
        /*
         * Client X has recevied DH paramters <p, g> and the server's
         * half key g_a from server in the session identified by <nc, ns>
         * for which the client has generated secret nonce nk.
         */
        ClientReceivesDHParameters(nc, ns, nk, g_a),
        
        /* 
         * Allow the process to continue only if the DH parameters 
         * are good or we explicitly allow weak parameters.
         */
        // WeakDHAllowed(p, g, g_a, 'DISALLOW_WEAK_DH'),
 
        /*
         * Client does/does not validate the received DH parameters.
         *
         * A broken client might accept DH parameters unconditionally. 
         * The following event allows us to test whether the client 
         * is running the protocol with bad parameters (in which 
         * case it is assumed that it has not checked them) or with 
         * strong parameters (in which case it is assumed that it has 
         * checked them).
         *
         * This fact is supposed to be checked using the 
         * following expression (or an equivalent one):
         * ClientChecksDHParameters(p, g, half)
         * ==>
         * (
         *   ¬(p = WEAK_MODULO) ∧
         *   ¬(g = BAD_ELEMENT) ∧
         *   ¬(half = BAD_ELEMENT)
         * )
         */
        // ClientChecksDHParameters(p, g, g_a),

        /*
         * Client X has accepted the DH paramteres <p, g> received 
         * from server in session <nc, ns> for which the client has
         * generated secret nonce nk and received the server's half
         * key g_a.
         */
        ClientAcceptsDHParameters(nc, ns, nk, g_a),

        /*
         * Client X completes the DH exchange with server in session 
         * <nc, ns> for which X has generate the secret nonce nk and has 
         * received DH parameters <p, g> and half key g_a by computing
         * the authorization key authKey and by sending its half key
         * g_b to the server.
         */
        ClientEndsDHExchange(nc, ns, nk, g_a, b, authKey),

        /*
         * Client X has negotiated the authorization key authKey with
         * server in session <nc, ns>.
         */
        ClientAcceptsAuthKey(nc, ns, nk, authKey)
      ]->
      [ 
        Out(<nc, ns, encAuthMsg2>),
        ClientAuthState_7(nc, nk, b, ns, spkey, g_a, authKey)
      ]


  /*
   * 9. Server sends ACK to client.
   */
  rule ServerAuth_9 [color=#3440eb]:
    let
      key        = genKey(ns, nk)
      iv         = genIV(ns, nk)
      // TODO: this g_b might not come from the client but from the earlier server message
      // that the server itself sent (reflection attack maybe possible ??)
      encAuthMsg = AES_IGE_enc(<nc, ns, g_b>, key, iv)
      authKey    = g_b ^ a 
    in
      [
        ServerAuthState_5(nc, ns, skey, pkey, nk, a, g_a),
        In(<nc, ns, encAuthMsg>)
      ]
    --[
        /*
         * Server completes the DH exchange with parameters <p, g>
         * in session <nc, ns> for which a client has generated
         * the secret nonce nk and the half key g_b by computing
         * the authorization key authKey.
         */
        ServerEndsDHExchange(nc, ns, nk, g_b, authKey),

        /*
         * Server has negotiated the authorization key authKey with a 
         * client in session <nc, ns>.
         */
        ServerAcceptsAuthKey(nc, ns, nk, authKey),
      
        /*
         * Server sends an acknowledgment to a client in session 
         * <nc, ns> for which the client has generated secret nonce nk.
         */
        ServerSendsAck(nc, ns, nk, authKey)

      ]->
      [ 
        Out(<nc, ns, hashNk(nk, authKey)>),

        /* Protocol ends here. The following is for testing queries. */
        !AuthKeyServer(keyID(authKey), authKey),
        !ServerEndsProtocol(nc, ns, nk, pkey, a, g_b, authKey)
      ]


  /*
   * 10. Client receives ACK from server.
   */
  rule ClientAuth_10 [color=#5feb34]:
      [
        ClientAuthState_7(nc, nk, b, ns, spkey, g_a, authKey),
        In(<nc, ns, hashNk(nk, authKey)>)
      ]
    --[
        /*
         * Client X has received an acknowledgment from the server for
         * the authorization key negotiated in session <nc, ns>.
         */
        ClientReceivesAck(nc, ns, nk, authKey)
      ]->
      [
        /* Protocol ends here. The following is for testing queries. */
        !AuthKeyClient($Server, authKey),
        !ClientEndsProtocol(nc, ns, nk, spkey, b, g_a, authKey)
      ]


/*****************************************************************/
/* Key registration and Diffie Hellman parameters                */
/*****************************************************************/

  /* Generates a new private/public key pair for a server. */
  rule RegisterRSAKey [color=#c334eb]:
      [ Fr(~sk) ]
    --[ RegisterRSAKey(~sk) ]->
      [
        !RSAServerKey($X, ~sk, pk(~sk)),
        !RSAPublicKey($X, pk(~sk), fpk(pk(~sk))),
        Out(pk(~sk)),
        Out($X)
      ]

  rule GenRandomServerNonce [color=#c334eb]:
      [ Fr(~ns) ]
    --[ RandomServerNonceGenerated(~ns) ]->
      [ NS(~ns) ]
 
  rule GenFixedServerNonce [color=#c334eb]:
      []
    --[ FixedServerNonceGenerated() ]->
      [ NS('FIXED_NS') ]

//  /* Generate good/bad DH parameters and save them. */
//  rule GenGoodDHParameter [color=#c334eb]:
//      [ Fr(~g) ]
//    --[ GoodDHParameterGenerated(~g) ]->
//      [ !DiffieHellmanParameter(~g) ]
//
//  rule GenBadDHParameter [color=#c334eb]:
//      []
//    --[ BadDHParameterGenerated(grpid) ]->
//      [ !DiffieHellmanParameter(grpid) ]
  

  /* 
   * Allows the attacker to register an authorization key for 
   * itself with a server.
   */
  rule RegisterAuthKey [color=#eb3434]:
      [ In(<X, authKey>) ]
    --[ 
        NotChoosePrincipal(X, $Alice, $Bob), 
        RegisterAuthKey(keyID(authKey), authKey) 
      ]->
      [ !AuthKeyServer(keyID(authKey), authKey) ]


/*****************************************************************/
/* Revealing of secret information                               */
/*****************************************************************/

  /* Reveals long-term secret of the server. */
  rule RevealRSAKey [color=#eb3434]:
      [ !RSAServerKey($Server, skey, pkey) ]
    --[ RevealedRSAKey(skey) ]->
      [ Out(skey) ]

//  /* Reveals session key shared between client and server. */
//  rule RevealAuthKey [color=#eb3434]:
//      [ 
//        !AuthProtClientEphemeralSecrets(nk, ~b),
//        !AuthProtServerEphemeralSecrets(~a),
//        !AuthKeyServer(fp, authKey), 
//        !AuthKeyClient($Server, authKey)
//      ]
//    --[ 
//        Eq('g'^~a^~b, authKey),
//        RevealedAuthKey(authKey)
//      ]->
//      [ Out(authKey) ]


  /* Reveals the secret client's nonce. */
  rule RevealNk [color=#eb3434]:
      [ !AuthProtClientEphemeralSecrets(nk, b) ]
    --[ RevealedNk(nk) ]->
      [ Out(nk) ]
  
  /* Reveals the client's DH secret exponent. */
  rule RevealAuthProtClientExponent [color=#eb3434]:
      [ !AuthProtClientEphemeralSecrets(nk, b) ]
    --[ RevealedAuthProtClientExponent(b) ]->
      [ Out(b) ]

  /* Reveals all client's ephemeral secrets. */
  rule RevealAuthProtClientEphemeralSecrets [color=#eb3434]:
      [ !AuthProtClientEphemeralSecrets(nk, b) ]
    --[ RevealedAuthProtClientEphemeralSecrets(nk, b) ]->
      [ Out(<nk, b>) ]

  /* Reveals the server's DH secret exponent. */
  rule RevealAuthProtServerExponent [color=#eb3434]:
      [ !AuthProtServerEphemeralSecrets(a) ]
    --[ RevealedAuthProtServerExponent(a) ]->
      [ Out(a) ]


/*****************************************************************/
/* Post-revealing of secret information                          */
/*****************************************************************/

// TODO: post-revealing rules cause partial deconstructions/non-termination
//
//  /* 
//   * Reveals the private key of the server after the protocol
//   * has been run (at least once).
//   */
//  rule PostCompromiseRSAKey [color=#eb3434]:
//      [
//        !ClientEndsProtocol(nc, ns, nk, pk, b, g_a, authKey),
//        !ServerEndsProtocol(nc, ns, nk, pk, a, g_b, authKey),
//        !RSAServerKey($Server, sk, pk)
//      ]
//    --[ PostCompromisedRSAKey(sk) ]->
//      [ Out(sk) ]
//
//  /*
//   * Reveals the secret nonce generated by the client after the 
//   * protocol has been run. 
//   */
//  rule PostCompromiseNonce [color=#eb3434]:
//      [ 
//        !AuthProtClientEphemeralSecrets(nk, b),
//        !AuthKeyServer(fp, authKey),
//        !AuthKeyClient($Server, authKey)
//      ]
//    --[ PostCompromisedNonce(nk) ]->
//      [ Out(nk) ]
//
//  /* Reveals an authorization key after the protocol has been run. */
//  rule PostCompromiseAuthKey [color=#eb3434]:
//      [ 
//        !AuthKeyServer(fp, authKey), 
//        !AuthKeyClient($Server, authKey)
//      ]
//    --[ PostCompromisedAuthKey(authKey) ]->
//      [ Out(authKey) ]
