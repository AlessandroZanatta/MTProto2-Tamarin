/*
 * MTProto 2.0: Rekeying
 *
 * Model for the protocol used for updating the session keys of secret chats.
 *
 * See: https://core.telegram.org/api/end-to-end/pfs
 */

/*****************************************************************/
/* Useful functions                                              */
/*****************************************************************/

  functions:
    ChooseOtherPrincipal/3

  equations:
    ChooseOtherPrincipal(X, X, Y) = Y,
    ChooseOtherPrincipal(X, Y, X) = Y


/*****************************************************************/
/* Protocol definition                                           */
/*****************************************************************/


  rule RekeyingInitiator_1 [color=#41a9a9]:
    let
      iUser = 'Alice'
      g_i   = 'g' ^ ~i

      m1    = <'HALF_KEY_I', ~exchangeID, g_i>
      mk1   = msgKey(m1, sessionKey)
      key1  = genKey(mk1, sessionKey)
      c1    = <keyID(sessionKey), mk1, senc(m1, key1)>
    in
      [
        In(rUser),

        /* 
         * Retrieve the session key sessionKey exchanged during the first
         * secret chat protocol run 
         */
        !SecretChatClient(iUser, iUser, rUser, ~old_i, chatID, sessionKey),
        
        /* Generate DH ephemeral key */
        Fr(~i),

        /* Generate session ID */
        Fr(~exchangeID)
      ]
    --[
        NotEq(iUser, rUser),
        InitiatorSendsHalfKey(~exchangeID, iUser, rUser, g_i)
      ]->
      [
        RekeyingInitiatorState_1(iUser, rUser, ~i, ~exchangeID, sessionKey),
        !RekeyingInitiatorEphemeralKey(~i),
        Out(c1)
      ]


  rule RekeyingResponder_2 [color=#4C6085]:
    let
      rUser  = 'Bob'

      g_i    = 'g' ^ ~i
      m1     = <'HALF_KEY_I', ~exchangeID, g_i>
      mk1    = msgKey(m1, sessionKey)
      key1   = genKey(mk1, sessionKey)
      c1     = <keyID(sessionKey), mk1, senc(m1, key1)>

      newKey = g_i ^ ~r
      fp     = fps(newKey)

      g_r    = 'g' ^ ~r
      m2     = <'HALF_KEY_R', ~exchangeID, g_r, fp>
      mk2    = msgKey(m2, sessionKey)
      key2   = genKey(mk2, sessionKey)
      c2     = <keyID(sessionKey), mk2, senc(m2, mk2)> 
    in
      [
        In(rUser),
        
        /* Generate responder DH ephemeral key */
        Fr(~r),

        /* 
         * Retrieve the session key sessionKey exchanged during the first
         * secret chat protocol run 
         */
        !SecretChatClient(rUser, iUser, rUser, ~old_r, chatID, sessionKey),

        In(c1)
      ]
    --[
        NotEq(iUser, rUser),
        ResponderReceivesHalfKey(~exchangeID, iUser, rUser, g_i),
        ResponderSendsHalfKey(~exchangeID, iUser, rUser, g_r, fp)
      ]->
      [
        RekeyingResponderState_2(iUser, rUser, ~r, ~exchangeID, sessionKey, newKey),
        !RekeyingResponderEphemeralKey(~r),
        Out(c2)
      ]


  rule RekeyingInitiator_3 [color=#41a9a9]:
    let
      g_r    = 'g' ^ ~r

      /*
       * This pattern matching is required to avoid partial deconstruction
       * coming from the ambiguity of the term fp
       */
      // fp     = fps('g' ^ ~e1 ^ ~e2)
      fp     = fps(otherPartyNewKey)
      m2     = <'HALF_KEY_R', ~exchangeID, g_r, fp>
      mk2    = msgKey(m2, sessionKey)
      key2   = genKey(mk2, sessionKey)
      c2     = <keyID(sessionKey), mk2, senc(m2, mk2)> 

      newKey = g_r ^ ~i

      m3     = <'FP_ACK', ~exchangeID, fp>
      mk3    = msgKey(m3, sessionKey)
      key3   = genKey(mk3, sessionKey)
      c3     = <keyID(sessionKey), mk3, senc(m3, key3)>
    in
      [
        RekeyingInitiatorState_1(iUser, rUser, ~i, ~exchangeID, sessionKey),
        In(c2)
      ]
    --[ 
        InitiatorReceivesHalfKey(~exchangeID, iUser, rUser, g_r, fp),
        RekeyingKeyFingerprintMatches(~exchangeID, iUser, rUser, fp, fps(newKey)),
        InitiatorHasNegotiatedNewKey(~exchangeID, iUser, rUser, newKey),
        InitiatorSendsAck(~exchangeID, iUser, rUser, fp) 
      ]->
      [
        Out(c3),

        /* End of the rekeying protocol */
        !RekeyingClient(iUser, iUser, rUser, ~i, ~exchangeID, newKey)
      ]

  rule RekeyingResponder_4 [color=#4C6085]:
    let
      fp     = fps(newKey)

      m3     = <'FP_ACK', ~exchangeID, fp>
      mk3    = msgKey(m3, sessionKey)
      key3   = genKey(mk3, sessionKey)
      c3     = <keyID(sessionKey), mk3, senc(m3, key3)>
    in
      [

        RekeyingResponderState_2(iUser, rUser, ~r, ~exchangeID, sessionKey, newKey),
        In(c3)
      ]
    --[
        ResponderReceivesAck(~exchangeID, iUser, rUser, fp),
        ResponderHasNegotiatedNewKey(~exchangeID, iUser, rUser, newKey)
      ]->
      [
        /* End of the rekeying protocol */
        !RekeyingClient(rUser, iUser, rUser, ~r, ~exchangeID, newKey)
      ]

/*****************************************************************/
/* Rekeying chat message sending/receiving rules                 */
/*****************************************************************/

  rule RekeyingSend [color=#0088CC]:
    let
      mk  = msgKey(~m, newKey)
      key = genKey(mk, newKey)      
      c   = <keyID(newKey), mk, senc(~m, key)>
    in
      [
        !RekeyingClient(X, iUser, rUser, ~xID, ~exchangeID, newKey),
        Fr(~m)
      ]
    --[
        Out_Rekeying_msg(c),
        ClientSendsMessageWithNewKey(~xID, X, ~exchangeID, iUser, rUser, newKey, ~m)
      ]->
      [ Out(c) ]


  rule RekeyingReceive [color=#0088CC]:
    let
      mk  = msgKey(~m, newKey)
      key = genKey(mk, newKey)      
      c   = <keyID(newKey), mk, senc(~m, key)>
    in
      [
        !RekeyingClient(X, iUser, rUser, ~xID, ~exchangeID, newKey),
        In(c)
      ]
    --[ 
        In_Rekeying_msg(c, ~m),
        ClientReceivesMessageWithNewKey(~xID, X, ~exchangeID, iUser, rUser, newKey, ~m)
      ]->
      []

//  lemma source [sources]:
//    "
//      ∀ c m #i.
//        In_Rekeying_msg(c, m) @i
//        ==>
//        (
//          (∃ #j. Out_Rekeying_msg(c) @j) ∨
//          (∃ #j. KU(m) @j ∧ #j < #i)
//        )
//    "

//      ∀ X Y A B #i.
//        ChooseOnlyOneHonestPrincipal(X, Y, A, B) @i
//        ==>
//        (
//          (X = A ∨ X = B) ∧
//          ¬(Y = A) ∧
//          ¬(Y = B)
//        )
//    "

/*****************************************************************/
/* Attacker capabilities                                         */
/*****************************************************************/

  rule CompromiseRekeyingInitiatorEphemeralKey [color=#FE4A49]:
      [ !RekeyingInitiatorEphemeralKey(~i) ]
    --[ CompromisedRekeyingInitiatorEphemeralKey(~i) ]->
      [ Out(~i) ]

  rule CompromiseRekeyingResponderEphemeralKey [color=#FE4A49]:
      [ !RekeyingResponderEphemeralKey(~r) ]
    --[ CompromisedRekeyingResponderEphemeralKey(~r) ]->
      [ Out(~r) ]

  /*
   * Allows the attacker to register a session key with an honest client, 
   * as if it had successfully run a session of the secret chat protocol 
   * with that client.
   */
  rule RegisterSessionKey [color=#FE4A49]:
    let
      sessionKey = 'g' ^ ~a ^ ~b
    in
      [ 
        In(X),
        Fr(~Y),
        Fr(~a),
        Fr(~b),
        Fr(~chatID),
        Fr(~authKey)
      ]
    --[
        ChoosePrincipal(X, 'Alice', 'Bob'),
        RegisteredSessionKey(sessionKey)
      ]->
      []

/*****************************************************************/
/* Other convenience functions                                   */
/*****************************************************************/

  rule GenerateSecretChatKey [color=#99C24D]:
    let
      X1 = 'Alice'
      X2 = 'Bob'
      sessionKey = 'g' ^ ~i ^ ~r
    in
      [
        Fr(~i),
        Fr(~r),
        Fr(~chatID)
      ]
    --[ ChoosePrincipal(X1, 'Alice', 'Bob') ]->
      [ 
        !SecretChatClient(X1, X1, X2, ~i, ~chatID, sessionKey),
        !SecretChatClient(X2, X1, X2, ~r, ~chatID, sessionKey),
        !SecretChatClient(X1, X2, X1, ~i, ~chatID, sessionKey),
        !SecretChatClient(X2, X2, X1, ~r, ~chatID, sessionKey)
      ]


  restriction RestrictionChoosePrincipal:
    "
      ∀ X Y Z #i.
        ChoosePrincipal(X, Y, Z) @i ==> ((X = Y) ∨ (X = Z))
    "

//  restriction RestrictionNotEq:
//    "
//      ∀ x y #i. NotEq(x, y) @i ==> ¬(x = y)
//    "
  
//  restriction RestrictionChooseOnlyOneHonestPrincipal:
//    "
//      ∀ X Y A B #i.
//        ChooseOnlyOneHonestPrincipal(X, Y, A, B) @i
//        ==>
//        (
//          (X = A ∨ X = B) ∧
//          ¬(Y = A) ∧
//          ¬(Y = B)
//        )
//    "
