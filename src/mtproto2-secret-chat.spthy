/*
 * MTProto 2.0: Secret Chats
 *
 * Model for the protocol used in secret chats.
 *
 * See: https://core.telegram.org/api/end-to-end
 */


/*
 * An encrypted chat's messages pass through the server, 
 * who should act as a forwarder. 
 *
 * Each message is encrypted twice: first, with the session key
 * shared only by the two communicating parties; then, with the long-term
 * authorization key of one of the clients. 
 *
 * When the server receives a message from a client A destined to 
 * client B, it decrypts the message using A's long-term shared key
 * (thus retrieving the payload encrypted with the clients's session key)
 * then re-encrypt the message with B's long-term key and sends it to B.
 */

  rule SecretChatInitiator_1:
      [        
        /* Ephemeral key */
        Fr(~i),

        /* Long-term key shared with the server */
        !AuthKeyClient($Server, authKey)
      ]
    --[
        /*
         * Client starts a run of the secret chat protocol,
         * identified by the ephemeral key ~i
         */
        InitiatorRequestsDHConfig(~i)
      ]->
      [ 
        !SecretChatInitiatorEphemeralKey(~i),
        SecretChatInitiatorState_1(~i, authKey),
        Out('GET_DH_CONFIG')
      ]

  rule SecretChatInitiator_1_1:
    let
      g_i = 'g_schat' ^ ~i
    in
      [
        SecretChatInitiatorState_1(~i, authKey),

        /*
         * This needs to actually be 'g_schat' (and NOT g), otherwise 
         * the model becomes extremely complex due to partial
         * deconstructions caused by this unrestrained term.
         */
        In(<'DH_CONFIG', 'g_schat'>),

        /* Chat identifier */
        Fr(~chatID)
      ]
    --[
        /*
         * Chat's initiator sends a request to start an encrypted chat
         * with another party with chat identified ~chatID
         */
        InitiatorRequestsEncryptedChat(~i, ~chatID)
      ]->
      [
        SecretChatInitiatorState_1_1(~i, ~chatID, authKey),
        Out(<'REQI', ~chatID, g_i>)
      ]

  rule SecretChatResponser_2:
      [
        /* Ephemeral key */
        Fr(~r),
        
        /* Long-term key shared with the server */
        !AuthKeyClient($Server, authKey),

        /* Secret chat initiator request */
        In(<'REQI', chatID, g_i>)
      ]
    --[
        /*
         * Client (responder) has received a request to start a chat
         * in chat session ~r with half key g_i
         */
        ResponderReceivesRequestForEncryptedChat(~r, chatID, g_i),

        /*
         * Client (responder) has accepted to start a chat session ~r.
         */
        ResponderAcceptsInitiator(~r, chatID)
      ]->
      [
        SecretChatResponderState_2(~r, chatID, authKey, g_i),
        Out(<'CHAT_ACCEPTED', chatID>)
      ]


  rule SecretChatResponser_2_1:
    let
      /* Pattern matching for the incoming half key */
      g_i        = 'g_schat' ^ ~i
    
      /* Responder half key and full key */
      g_r        = 'g_schat' ^ ~r
      sessionKey = g_i ^ ~r
      fp         = fps(sessionKey)
    in
      [
        SecretChatResponderState_2(~r, chatID, authKey, g_i),
        In(<'DH_CONFIG', 'g_schat'>)
      ]
    --[
        /*
         * Responder has computed session key sessionKey in chat session ~r
         * started by initiator
         */
        ResponderHasSessionKeyForEncryptedChat(~r, chatID, sessionKey)
      ]->
      [ 
        SecretChatResponderState_2_1(~r, chatID, authKey, g_i, sessionKey),
        Out(<'ACCEPTR', chatID, g_r, fp>),
        !QR(~r, sessionKey)
      ]

  rule SecretChatInitiator_3:
    let
      g_r = 'g_schat' ^ ~r
      sessionKey = g_r ^ ~i
    in
      [
        SecretChatInitiatorState_1_1(~i, ~chatID, authKey),
        In(<'ACCEPTR', ~chatID, g_r, fp>)
      ]
    --[
        /*
         * The session key received in chat session ~i matches/does not match
         * the session key's fingerprint.
         *
         * Lemmas using this fact are supposted to check if third and fourth
         * arguments are actually the same (matches) or not (does not match).
         */
        SessionKeyFingerprintMatches(~i, ~chatID, fp, fps(sessionKey)),

        /*
         * Inititator has computed sessione key sessionKey in chat session ~i
         */
        InitiatorHasSessionKeyForEncryptedChat(~i, ~chatID, sessionKey)
      ]->
      [
        SecretChatInitiatorState_3(~i, ~chatID, authKey, g_r, sessionKey),
        
        /*
         * Out-of-band comparison of the generated session key is 
         * a crucial step to avoid MitM attacks. This step is 
         * delegated to two rules, one that performs this step 
         * correctly and one that doesn't. 
         *
         * This way we can model a user's misbehaviour.
         */
        !QR(~i, sessionKey)
      ]

  rule SecretChatResponder_4:
      [
        SecretChatResponderState_2_1(~r, chatID, authKey, g_i, sessionKey),
        !QROK(~r, sessionKey)
      ]
    --[
        /*
         * Responder has completed session ~r of the secret chat protocol
         * negotiating with initiator a shared key sessionKey
         */
        ResponderAcceptsEncryptedChat(~r, chatID, sessionKey)
      ]->
      [
        /* End of the protocol. Used for the rekeying protocol. */
        !SecretChatClient(~r, chatID, sessionKey, authKey)
      ]

  rule SecretChatInitiator_5:
      [
        SecretChatInitiatorState_3(~i, ~chatID, authKey, g_r, sessionKey),
        !QROK(~i, sessionKey)
      ]
    --[
        /*
         * Chat initiator has completed session ~i of the secret chat protocol
         * negotiating with responder a shared key sessionKey
         */
        InitiatorAcceptsEncryptedChat(~i, ~chatID, sessionKey)
      ]->
      [
        !SecretChatClient(~i, ~chatID, sessionKey, authKey)
      ]

/*****************************************************************/
/* QR verification rules                                         */
/*****************************************************************/

  rule PerformOutOfBandKeyComparison:
      [ 
        !QR(aID, sessionKey),
        !QR(bID, sessionKey)
      ]
    --[ 
        /* Rule out the possibility of sessions of a client with itself */
        NotEq(aID, bID),

        OutOfBandKeyComparisonSucceeded(aID, sessionKey),
        OutOfBandKeyComparisonSucceeded(bID, sessionKey)
      ]->
      [
        !QROK(aID, sessionKey)
      ]

  rule SkipOutOfBandKeyComparison:
      [ !QR(id, sessionKey) ]
    --[
        OutOfBandKeyComparisonSkipped(id, sessionKey)
      ]->
      [ !QROK(id, sessionKey) ]


/*****************************************************************/
/* Secret chat message sending/receiving rules                   */
/*****************************************************************/

  rule SecretChatSend:
    let
      mk  = msgKey(sessionKey, ~m)
      key = kdfKey(sessionKey, mk)
      iv  = kdfIV(sessionKey, mk)

      c   = <keyID(sessionKey), mk, senc(~m, key, iv)>
    in
      [ 
        !SecretChatClient(x, chatID, sessionKey, authKey),
        Fr(~m)
      ]
    --[
        ClientSendsSecretChatMsg(x, chatID, ~m, sessionKey, authKey)
      ]->
      [
        Out(c)
      ]

  rule SecretChatReceive:
    let
      mk  = msgKey(sessionKey, m)
      key = kdfKey(sessionKey, mk)
      iv  = kdfIV(sessionKey, mk)

      c   = <keyID(sessionKey), mk, senc(m, key, iv)>
    in
      [
        !SecretChatClient(x, chatID, sessionKey, authKey),
        In(c)
      ]
    --[ ClientReceivesSecretChatMsg(x, chatID, m, sessionKey, authKey) ]->
      []

/*****************************************************************/
/* Other convenience functions                                   */
/*****************************************************************/

  rule GenerateDHConfig:
      []
    -->
      [ Out(<'DH_CONFIG', 'g_schat'>) ]

/*****************************************************************/
/* Attacker capabilities                                         */
/*****************************************************************/

  rule CompromiseSecretChatInitiatorEphemeralKey:
      [ !SecretChatInitiatorEphemeralKey(~i) ]
    --[ CompromisedSecretChatInitiatorEphemeralKey(~i) ]->
      [ Out(~i) ]

  rule CompromiseSecretChatResponderEphemeralKey:
      [ !SecretChatResponderEphemeralKey(~r) ]
    --[ CompromisedSecretChatResponderEphemeralKey(~r) ]->
      [ Out(~r) ]
