
  
/*****************************************************************/
/* Helpers                                                       */
/*****************************************************************/

  /* 
   * These constants are used to distinguish client->server from
   * server->client messages.
   *
   * Public constants:
   *  - CLIENT
   *  - SERVER
   */
  
/*****************************************************************/
/* Protocol rules                                                */
/*****************************************************************/

//  rule FakeAuthKeys:
//    let
//      authKey = 'g' ^ ~c ^ ~s
//    in
//      [
//        Fr(~c),
//        Fr(~s)
//      ]
//      -->
//      [
//        !AuthKeyClient($Server, authKey),
//        !AuthKeyServer(keyID(authKey), authKey)
//      ]

  rule ClientCloudChat_1 [color=#E2C290]:
    let
      msg1 = <'CLIENT', ~sessionID, ~m1>
      mk1  = msgKey(authKey, msg1)
      c1   = senc(msg1, kdfKey(authKey, mk1), kdfIV(authKey, mk1))
    in
      [ 
        /* 
         * Retrieve the long-term shared key between client and server 
         */
        !AuthKeyClient($Server, authKey),

        /*
         * Telegram uses a random 64-bits number generated by the client
         * to distinguish between individual sessions. This is sent along
         * with the encrypted message.
         */
        Fr(~sessionID),
      
        /* 
         * Fresh message to be sent to the server.
         * This is supposed to remain secret. 
         */
        Fr(~m1)
      ]
    --[
        /*
         * The client has sent the cloud message ~m1 in session
         * with id ~sessionID and with authorization key authKey
         */
        ClientSendsCloudMessage(~sessionID, ~m1, authKey)
      ]->
      [ 
        ClientCloudChatState_1(<~sessionID, authKey, ~m1>),
        Out(<keyID(authKey), mk1, c1>)
      ]
  
  rule ServerCloudChat_2 [color=#0088CC]:
    let
      /* Pattern matching for the incoming message */
      mk1  = msgKey(authKey, msg1)
      msg1 = <'CLIENT', ~sessionID, m1>
      c1   = senc(msg1, kdfKey(authKey, mk1), kdfIV(authKey, mk1))

      /* Outgoing message creation */
      msg2 = <'SERVER', ~sessionID, ~m2>
      mk2  = msgKey(authKey, msg2)
      c2   = senc(msg2, kdfKey(authKey, mk2), kdfIV(authKey, mk2))
    in
      [ 
        In(<kID, mk1, c1>),

        /* Long-term key shared with the server */
        !AuthKeyServer(kID, authKey),

        /* 
         * Fresh message to be sent to the client. 
         * This is supposed to remain secret 
         */
        Fr(~m2)
      ]
    --[
        /*
         * Server has received the message m1 in session
         * sessionID using the authorization key authKey
         */
        ServerReceivesCloudMessage(~sessionID, m1, authKey),

        /*
         * Server has sent the message ~m2 in session
         * sessionID using the authorization key authKey
         */
        ServerSendsCloudMessage(~sessionID, ~m2, authKey)
      ]->
      [ 
        ServerCloudChatState_2(<~sessionID, authKey, m1, ~m2>),
        Out(<keyID(authKey), mk2, c2>)
      ]

  
  rule ClientCloudChat_3 [color=#E2C290]:
    let
      kID  = keyID(authKey)
      
      /* Pattern matching for the incoming message */
      msg2 = <'SERVER', ~sessionID, m2>
      mk2  = msgKey(authKey, msg2)
      c2   = senc(msg2, kdfKey(authKey, mk2), kdfIV(authKey, mk2))
    in
      [ 
        ClientCloudChatState_1(<~sessionID, authKey, ~m1>),
        In(<kID, mk2, c2>)
      ]
    --[ 
        /*
         * Client has received the message m1 in session
         * sessionID using the authorization key authKey
         */
        ClientReceivesCloudMessage(~sessionID, m2, authKey)
      ]->
      [ ClientCloudChatState_3(<~sessionID, authKey, ~m1, m2>) ]

