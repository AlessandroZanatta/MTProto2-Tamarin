
  
/*****************************************************************/
/* Helpers                                                       */
/*****************************************************************/

  /* 
   * These constants are used to distinguish client->server from
   * server->client messages.
   *
   * Public constants:
   *  - CtoS
   *  - StoC
   */
  
/*****************************************************************/
/* Protocol rules                                                */
/*****************************************************************/

  rule ClientCloudChatSendsMessage [color=#E2C290]:
    let
      msg = <'CtoS', ~sessionID, ~m>
      mk  = msgKey(msg, authKey)
      key = genKey(mk, authKey)
      c   = senc(msg, key)
    in
      [
        /* 
         * Retrieve the long-term shared key between client and server 
         */
        !AuthKeyClient($Server, authKey),

        /*
         * Telegram uses a random 64-bits number generated by the client
         * to distinguish between individual sessions. This is sent along
         * with the encrypted message.
         */
        Fr(~sessionID),
      
        /* 
         * Fresh message to be sent to the server.
         * This is supposed to remain secret. 
         */
        Fr(~m)
      ]
    --[
        Out_ClientCloudChat(c),
        /*
         * The client has sent the cloud message ~m1 in session
         * with id ~sessionID and with authorization key authKey
         */
        ClientSendsCloudMessage(~sessionID, ~m, authKey)
      ]->
      [ Out(<keyID(authKey), c>) ]
  

  rule ServerCloudChatReceivesMessage [color=#0088CC]:
    let
      /* Pattern matching for the incoming message */
      msg = <'CtoS', ~sessionID, ~m>
      mk  = msgKey(msg, authKey)
      key = genKey(mk, authKey)
      c   = senc(msg, key)
    in
      [ 
        In(<kID, c>),

        /* Long-term key shared with the client */
        !AuthKeyServer(kID, authKey)
      ]
    --[
        In_ServerCloudChat(c, ~m),
        /*
         * Server has received the message m1 in session
         * sessionID using the authorization key authKey
         */
        ServerReceivesCloudMessage(~sessionID, ~m, authKey)
      ]->
      []


  rule ServerCloudChatSendsMessage:
    let
      kID = keyID(authKey)

      msg = <'StoC', ~sessionID, ~m>
      mk  = msgKey(msg, authKey)
      key = genKey(mk, authKey)
      c   = senc(msg, key)
    in
      [
        /* Long-term key shared with the client */
        !AuthKeyServer(kID, authKey),

        Fr(~sessionID),

        /* 
         * Fresh message to be sent to the client. 
         * This is supposed to remain secret 
         */
        Fr(~m)
      ]
    --[
        Out_ServerCloudChat(c),
        /*
         * Server has sent the message ~m in session
         * sessionID using the authorization key authKey
         */
        ServerSendsCloudMessage(~sessionID, ~m, authKey)
      ]->
      [ Out(<kID, c>) ]


  rule ClientCloudChatReceivesMessage [color=#E2C290]:
    let
      kID  = keyID(authKey)
      
      /* Pattern matching for the incoming message */
      msg = <'StoC', ~sessionID, ~m>
      mk  = msgKey(msg, authKey)
      key = genKey(mk, authKey)
      c   = senc(msg, key)
    in
      [ 
        /* 
         * Retrieve the long-term shared key between client and server 
         */
        !AuthKeyClient($Server, authKey),

        In(<kID, c>)
      ]
    --[ 
        In_ClientCloudChat(c, ~m),
        /*
         * Client has received the message m1 in session
         * sessionID using the authorization key authKey
         */
        ClientReceivesCloudMessage(~sessionID, ~m, authKey)
      ]->
      []

  lemma source [sources]:
    "
      (
        ∀ m c #i.
          In_ServerCloudChat(c, m) @i
          ==>
          (
            (∃ #r. Out_ClientCloudChat(c) @r) ∨
            (∃ #r. KU(m) @r ∧ #r < #i)
          )
      ) ∧
      (
        ∀ m c #i.
          In_ClientCloudChat(c, m) @i
          ==>
          (
            (∃ #r. Out_ServerCloudChat(c) @r) ∨
            (∃ #r. KU(m) @r ∧ #r < #i)
          )
      )
    "
