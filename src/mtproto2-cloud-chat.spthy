
  
/*****************************************************************/
/* Helpers                                                       */
/*****************************************************************/

  /* 
   * These constants are used to distinguish client->server from
   * server->client messages.
   *
   * Public constants:
   *  - CtoS
   *  - StoC
   */
  
/*****************************************************************/
/* Protocol rules                                                */
/*****************************************************************/

  rule ClientCloudChatSendsMessage [color=#E2C290]:
    let
      msg = <'CtoS', ~sessionID, ~m>
      mk  = msgKey(authKey, msg)
      c   = senc(msg, kdfKey(authKey, mk), kdfIV(authKey, mk))
    in
      [
        /* 
         * Retrieve the long-term shared key between client and server 
         */
        !AuthKeyClient($Server, authKey),

        /*
         * Telegram uses a random 64-bits number generated by the client
         * to distinguish between individual sessions. This is sent along
         * with the encrypted message.
         */
        Fr(~sessionID),
      
        /* 
         * Fresh message to be sent to the server.
         * This is supposed to remain secret. 
         */
        Fr(~m)
      ]
    --[
        /*
         * The client has sent the cloud message ~m1 in session
         * with id ~sessionID and with authorization key authKey
         */
        ClientSendsCloudMessage(~sessionID, ~m, authKey)
      ]->
      [ Out(<keyID(authKey), mk, c>) ]
  

  rule ServerCloudChatReceivesMessage [color=#0088CC]:
    let
      /* Pattern matching for the incoming message */
      mk  = msgKey(authKey, msg)
      msg = <'CtoS', ~sessionID, ~m>
      c   = senc(msg, kdfKey(authKey, mk), kdfIV(authKey, mk))
    in
      [ 
        In(<kID, mk, c>),

        /* Long-term key shared with the client */
        !AuthKeyServer(kID, authKey)
      ]
    --[
        /*
         * Server has received the message m1 in session
         * sessionID using the authorization key authKey
         */
        ServerReceivesCloudMessage(~sessionID, ~m, authKey)
      ]->
      []


  rule ServerCloudChatSendsMessage:
    let
      kID = keyID(authKey)

      msg = <'StoC', ~sessionID, ~m>
      mk  = msgKey(authKey, msg)
      c   = senc(msg, kdfKey(authKey, mk), kdfIV(authKey, mk))
    in
      [
        /* Long-term key shared with the client */
        !AuthKeyServer(kID, authKey),

        Fr(~sessionID),

        /* 
         * Fresh message to be sent to the client. 
         * This is supposed to remain secret 
         */
        Fr(~m)
      ]
    --[
        /*
         * Server has sent the message ~m in session
         * sessionID using the authorization key authKey
         */
        ServerSendsCloudMessage(~sessionID, ~m, authKey)
      ]->
      [ Out(<kID, mk, c>) ]


  rule ClientCloudChatReceivesMessage [color=#E2C290]:
    let
      kID  = keyID(authKey)
      
      /* Pattern matching for the incoming message */
      msg = <'StoC', ~sessionID, ~m>
      mk  = msgKey(authKey, msg)
      c   = senc(msg, kdfKey(authKey, mk), kdfIV(authKey, mk))
    in
      [ 
        /* 
         * Retrieve the long-term shared key between client and server 
         */
        !AuthKeyClient($Server, authKey),

        In(<kID, mk, c>)
      ]
    --[ 
        /*
         * Client has received the message m1 in session
         * sessionID using the authorization key authKey
         */
        ClientReceivesCloudMessage(~sessionID, ~m, authKey)
      ]->
      []

