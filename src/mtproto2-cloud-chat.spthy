

/*****************************************************************/
/* Helpers                                                       */
/*****************************************************************/

/* 
 * These constants are used to distinguish client->server from
 * server->client messages.
 *
 * Public constants:
 *  - CLIENT
 *  - SERVER
 */

  rule CreateSharedAuthKey:
    let
      authKey = 'g' ^ ~a ^ ~b
    in
      [ Fr(~a), Fr(~b) ]
    --[ FakeSharedAuthKey(authKey) ]->
      [
        !AuthKeyClient($Server, authKey),
        !AuthKeyServer(keyID(authKey), authKey)
      ]

/*****************************************************************/
/* Protocol rules                                                */
/*****************************************************************/


  rule ClientCloudChat_1:
    let
      msg1 = <'CLIENT', ~sessionID, ~m1>
      mk1  = msgKey(authKey, msg1)
      c1   = senc(msg1, kdfKey(authKey, mk1), kdfIV(authKey, mk1))
    in
      [ 
        /* 
         * Retrieve the long-term shared key between client and server 
         */
        !AuthKeyClient($Server, authKey),

        /*
         * Telegram uses a random 64-bits number generated by the client
         * to distinguish between individual sessions. This is sent along
         * with the encrypted message.
         */
        Fr(~sessionID),
      
        /* Message from the client. This is supposed to be secret. */
        Fr(~m1)
      ]
    --[ ClientSendsCloudMessage(~sessionID, ~m1, authKey) ]->
      [ 
        ClientCloudChatState_1(<~sessionID, authKey, ~m1>),
        Out(<keyID(authKey), mk1, c1>)
      ]
  
  rule ServerCloudChat_2:
    let
      /* Pattern matching for the incoming message */
      mk1  = msgKey(authKey, msg1)
      msg1 = <'CLIENT', sessionID, m1>
      c1   = senc(msg1, kdfKey(authKey, mk1), kdfIV(authKey, mk1))

      /* Outgoing message creation */
      msg2 = <'SERVER', sessionID, ~m2>
      mk2  = msgKey(authKey, msg2)
      c2   = senc(msg2, kdfKey(authKey, mk2), kdfIV(authKey, mk2))
    in
      [ 
        In(<kID, mk1, c1>),
        !AuthKeyServer(kID, authKey),
        Fr(~m2)
      ]
    --[
        ServerReceivesCloudMessage(sessionID, m1, authKey),
        ServerSendsCloudMessage(sessionID, ~m2, authKey)
      ]->
      [ 
        ServerCloudChatState_2(<sessionID, authKey, m1, ~m2>),
        Out(<keyID(authKey), mk2, c2>)
      ]

  
  rule ClientCloudChat_3:
    let
      kID  = keyID(authKey)
      
      /* Pattern matching for the incoming message */
      msg2 = <'SERVER', ~sessionID, m2>
      mk2  = msgKey(authKey, msg2)
      c2   = senc(msg2, kdfKey(authKey, mk2), kdfIV(authKey, mk2))
    in
      [ 
        ClientCloudChatState_1(<~sessionID, authKey, ~m1>),
        In(<kID, mk2, c2>)
      ]
    --[ ClientReceivesCloudMessage(~sessionID, m2, authKey) ]->
      [ ClientCloudChatState_3(<~sessionID, authKey, ~m1, m2>) ]


// Sending another message to check for post-compromise 
// should NOT be needed in Tamarin.
//
//  rule ClientCloudChat_3:
//    let
//      kID  = keyID(authKey)
//      
//      /* Pattern matching for the incoming message */
//      msg2 = <'CLIENT', ~sessionID, m2>
//      mk2  = msgKey(authKey, msg2)
//      c2   = senc(msg2, kdfKey(authKey, mk2), kdfIV(authKey, mk2))
//
//      /* Outgoing message creation */
//      msg3 = <'SERVER', ~sessionID, ~m3>
//      mk3  = msgKey(authKey, msg3)
//      c3   = senc(msg3, kdfKey(authKey, mk3), kdfIV(authKey, mk3))
//    in
//      [ 
//        ClientCloudChatState_1(<~sessionID, authKey, ~m1>),
//        In(<kID, mk2, c2>),
//        Fr(~m3)
//      ]
//    --[ 
//        ClientReceivesCloudMessage(~sessionID, m2, authKey),
//        ClientSendsCloudMessageAfterCompromisedNonce(~sessionID, ~m3, authKey)
//      ]->
//      [ 
//        ClientCloudChatState_3(<~sessionID, authKey, ~m1, m2, ~m3>),
//        Out(<kID, mk3, c3>)
//      ]
//  
//
//
//  rule ServerCloudChat_4:
//    let
//      kID  = keyID(authKey)
//
//      /* Pattern matching for the incoming message */
//      msg3 = <'CLIENT', sessionID, m3>
//      mk3  = msgKey(authKey, msg3)
//      c3   = senc(msg3, kdfKey(authKey, mk3), kdfIV(authKey, mk3))
//    in
//      [
//        ServerCloudChatState_2(<sessionID, authKey, m1, ~m2>),
//        In(<kID, mk3, c3>)
//      ]
//    --[ ServerReceivesCloudMessageAfterCompromisedNonce(sessionID, m3, authKey) ]->
//      [ 
//        ServerCloudChatState_2(<sessionID, authKey, m1, ~m2, m3>)
//      ]
//