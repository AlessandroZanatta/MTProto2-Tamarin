

/*****************************************************************/
/* Private data                                                  */
/*****************************************************************/

  functions: 
    secretAuthMsg1/0 [private],
    secretAuthMsg2/0 [private],
    secretAuthMsg3/0 [private]


/*****************************************************************/
/* Helper functions                                              */
/*****************************************************************/

/* 
 * These constants are used to distinguish client->server from
 * server->client messages.
 *
 * Public constants:
 *  - CLIENT
 *  - SERVER
 */

/* Constructor for encrypted part of a cloud-chat message */
  functions:
    /*
     * Arguments:
     *  - 
     *  - a nonce
     *  - 
     */
    CC/3,
    CC_1/1,
    CC_2/1,
    CC_3/1

  equations:
    CC_1(CC(a, b, c)) = a,
    CC_2(CC(a, b, c)) = b,
    CC_3(CC(a, b, c)) = c


/* Constructor for a message */
  functions:
    /*
     * Arguments:
     *  - a message
     */
    MSG/1,
    MSG_1/1

  equations:
    MSG_1(MSG(m)) = m

/*****************************************************************/
/* Protocol rules                                                */
/*****************************************************************/


  rule ClientCloudChat_1:
    let
      msg1 = CC('CLIENT', ~sessionID, secretAuthMsg1)
    in
      [ 
        In(X),
        
        /* 
         * Retrieve the long-term shared key between client and server 
         */
        !AuthKeyClient(X, $Server, authKey),
        
        /*
         * Telegram uses a random 64-bits number generated by the client
         * to distinguish between individual sessions. This is sent along
         * with the encrypted message.
         */
        Fr(~sessionID),

        /* Internally used to match encoding requests. */
        Fr(~msgID)
      ]
    --[ 
        ChoosePrincipal(X, $Alice, $Bob)
      ]->
      [ 
        ClientCloudChatState(X, 'STEP_1_1', <$Server, ~sessionID, authKey>, ~msgID),
        RequestEncodeCloudChatMsg(~msgID, msg1, authKey)
      ]


  rule ClientCloudChat_1_1:
      [
        ClientCloudChatState(X, 'STEP_1_1', <server, sessionID, authKey>, msgID),
        EncodedCloudChatMsg(msgID, encoded_msg)
      ]
    --[ ClientSendsCloudMessage(server, sessionID, secretAuthMsg1, authKey) ]->
      [
        Out(MSG(encoded_msg)),
        ClientCloudChatState(X, 'STEP_1_2', <server, sessionID, authKey>, msgID)
      ]
  
  rule ServerCloudChat_2:
      [ 
        In(MSG(msg)),
        Fr(~msgID)
      ]
    -->
      [ 
        RequestServerDecodeCloudChatMsg(~msgID, msg),
        ServerCloudChatState($Server, 'STEP_2_1', 'EMPTY_STATE', ~msgID)
      ]

  rule ServerCloudChat_2_1:
    let
      msg1 = CC('CLIENT', sessionID, plaintext1)
      msg2 = CC('SERVER', sessionID, secretAuthMsg2)
    in
      [ 
        ServerCloudChatState(server, 'STEP_2_1', 'EMPTY_STATE', msgID),
        ServerDecodedCloudChatMsg(msgID, msg1, authKey),
        Fr(~newMsgID)
      ]
    --[ ServerReceivesCloudMessage(server, sessionID, plaintext1, authKey) ]->
      [
        RequestEncodeCloudChatMsg(~newMsgID, msg2, authKey),
        ServerCloudChatState(server, 'STEP_2_2', <sessionID, authKey>, ~newMsgID)
      ]

  rule ServerCloudChat_2_2:
      [
        ServerCloudChatState(server, 'STEP_2_2', <sessionID, authKey>, msgID),
        EncodedCloudChatMsg(msgID, encoded_msg)
      ]
    --[ ServerSendsCloudMessage(server, sessionID, secretAuthMsg2, authKey) ]->
      [
        Out(MSG(encoded_msg)),
        ServerCloudChatState(server, 'STEP_2_3', <sessionID, authKey>, msgID)
      ]

  rule ClientCloudChat_3:
      [ 
        ClientCloudChatState(X, 'STEP_1_2', <server, sessionID, authKey>, msgID),
        In(MSG(encoded_msg)),
        Fr(~newMsgID)
      ]
    -->
      [ 
        RequestClientDecodeCloudChatMsg(~newMsgID, encoded_msg, authKey),
        ClientCloudChatState(X, 'STEP_3_1', <server, sessionID, authKey>, ~newMsgID)
      ]

  rule ClientCloudChat_3_1:
    let
      msg2 = CC('SERVER', sessionID, plaintext2)
      msg3 = CC('CLIENT', sessionID, secretAuthMsg3)
    in
      [
        ClientCloudChatState(X, 'STEP_3_1', <server, sessionID, authKey>, msgID),
        ClientDecodedCloudChatMsg(msgID, msg2),
        Fr(~newMsgID)
      ]
    --[ ClientReceivesCloudMessage(server, sessionID, plaintext2, authKey) ]->
      [
        ClientCloudChatState(X, 'STEP_3_2', <server, sessionID, authKey>, ~newMsgID),
        RequestEncodeCloudChatMsg(~newMsgID, msg3, authKey)
      ]

  rule ClientCloudChat_3_2:
      [
        // TODO: switch to phase 1 here
        ClientCloudChatState(X, 'STEP_3_2', <server, sessionID, authKey>, msgID),
        EncodedCloudChatMsg(msgID, encoded_msg)
      ]
    --[ ClientSendsCloudMessageAfterCompromisedNonce(server, sessionID, secretAuthMsg3, authKey) ]->
      [ Out(MSG(encoded_msg)) ]
  
  rule ServerCloudChat_4:
      [
        // TODO: switch to phase 1 here
        ServerCloudChatState(server, 'STEP_2_3', <sessionID, authKey>, msgID),
        In(MSG(encoded_msg)),
        Fr(~newMsgID)
      ]
    -->
      [ 
        RequestServerDecodeCloudChatMsg(~newMsgID, encoded_msg),
        ServerCloudChatState(server, 'STEP_3_1', <sessionID, authKey>, ~newMsgID)
      ]

  rule ServerCloudChat_4_1:
    let
      msg3 = CC('CLIENT', sessionID, plaintext3)
    in
      [
        ServerCloudChatState(server, 'STEP_3_1', <sessionID, authKey>, msgID),
        ServerDecodedCloudChatMsg(msgID, msg3, authKey)
      ]
    --[ ServerReceivesCloudMessageAfterCompromisedNonce(server, sessionID, plaintext3, authKey) ]->
      []
