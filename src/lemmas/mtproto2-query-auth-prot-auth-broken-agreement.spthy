
  /*
   * Key agreement: if client and server end up negotiating an authorization
   * key in a session executed correctly, then the key is the same.
   *
   * In this session the server's private key is revealed. In this case
   * there is no guarantee (everything can be learned by the attacker).
   *
   * Expected result: False
   * Estimated time: ~20 seconds
   */
  lemma LemmaAuthProtBrokenAgreement_1:
    "

      ∀ nc ns nk1 nk2 shared_key1 shared_key2 #i #j.
        /* 
         * Whenever a client and a server have accepted an authKey 
         * in session <nc, ns>
         */
        ServerAcceptsAuthKey(nc, ns, nk1, shared_key1) @i ∧
        ClientAcceptsAuthKey(nc, ns, nk2, shared_key2) @j ∧
        
        /* and no secret was leaked but the secret key of the server */
          ¬(∃ sk #r.   RegisteredSharedKey(sk) @r) ∧
          ¬(∃ sk #r.   CompromisedSharedKey(sk) @r) ∧
          // ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r) ∧
          ¬(∃ skey #r. PostCompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    PostCompromisedNonce(n) @r) ∧
          ¬(∃ c #r.    PostCompromisedClientExponent(c) @r) ∧
          ¬(∃ s #r.    PostCompromisedServerExponent(s) @r)
        ==>
        (
          /* then client and server have computed the same authKey */
          (shared_key1 = shared_key2) ∨
         
          /* or the server re-used the server nonce */
          (
            ∃ #k1 #k2.
              ServerGeneratesNonce(ns) @k1 ∧
              ServerGeneratesNonce(ns) @k2 ∧
              ¬(#k1 = #k2)
          )
        )
    "

  /*
   * Key agreement: If client and server end up negotiating an authorization
   * key in a session executed correctly, then the key is the same.
   *
   * If the secret nonce nk is leaked, then the attacker can act as a MITM
   * on the DH exchange.

   * Expected result: False
   * Estimated time: ~30 seconds
   */
  lemma LemmaAuthProtBrokenAgreement_2:
    "

      ∀ nc ns nk1 nk2 shared_key1 shared_key2 #i #j.
        /* 
         * Whenever a client and a server have accepted an authKey 
         * in session <nc, ns>
         */
        ServerAcceptsAuthKey(nc, ns, nk1, shared_key1) @i ∧
        ClientAcceptsAuthKey(nc, ns, nk2, shared_key2) @j ∧
        
        /* and no secret was leaked but the secret nonce of the client */
          ¬(∃ sk #r.   RegisteredSharedKey(sk) @r) ∧
          ¬(∃ sk #r.   CompromisedSharedKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          // ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r) ∧
          ¬(∃ skey #r. PostCompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    PostCompromisedNonce(n) @r) ∧
          ¬(∃ c #r.    PostCompromisedClientExponent(c) @r) ∧
          ¬(∃ s #r.    PostCompromisedServerExponent(s) @r)
        ==>
        (
          /* then client and server have computed the same authKey */
          (shared_key1 = shared_key2) ∨
         
          /* or the server re-used the server nonce */
          (
            ∃ #k1 #k2.
              ServerGeneratesNonce(ns) @k1 ∧
              ServerGeneratesNonce(ns) @k2 ∧
              ¬(#k1 = #k2)
          )
        )
    "

  /*
   * Key agreement: If client and server end up negotiating an authorization
   * key in a session executed correctly, then the key is the same.
   *
   * If the DH exponents are revealed, the attacker can of course compute
   * the authorization key, but he cannot force the client and the server
   * to compute two different keys, nor he can act as a MITM. This means
   * that the key agreement actually holds (while secrecy will not).
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtBrokenAgreement_3:
    "
      ∀ nc ns nk1 nk2 shared_key1 shared_key2 #i #j.
        /* 
         * Whenever a client and a server have accepted an authKey 
         * in session <nc, ns>
         */
        ServerAcceptsAuthKey(nc, ns, nk1, shared_key1) @i ∧
        ClientAcceptsAuthKey(nc, ns, nk2, shared_key2) @j ∧
        
        /* and no secret was leaked but the secret DH exponents */
          ¬(∃ sk #r.   RegisteredSharedKey(sk) @r) ∧
          ¬(∃ sk #r.   CompromisedSharedKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          // ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          // ¬(∃ s #r.    CompromisedServerExponent(s) @r) ∧
          ¬(∃ skey #r. PostCompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    PostCompromisedNonce(n) @r) ∧
          ¬(∃ c #r.    PostCompromisedClientExponent(c) @r) ∧
          ¬(∃ s #r.    PostCompromisedServerExponent(s) @r)
        ==>
        (
          /* 
           * then client and server have computed the same authKey
           */
          (shared_key1 = shared_key2) ∨
         
          /* or the server re-used the server nonce. */
          (
            ∃ #k1 #k2.
              ServerGeneratesNonce(ns) @k1 ∧
              ServerGeneratesNonce(ns) @k2 ∧
              ¬(#k1 = #k2)
          )
        )
    "