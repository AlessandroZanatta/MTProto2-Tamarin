
  /*
   * Key agreement: if client and server end up negotiating an authorization
   * key in a session executed correctly (and without revealing any secret),
   * then the key is the same.
   *
   * Note: here we're assuming that no secret (ephemeral or long-term) is
   * revealed. This assumption is captured by the last part of the formula.
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtAgreement:
    "
      /* Whenever a client and a server negotiate an authorization key */
      ∀ nc ns nk shared_key1 shared_key2 #i #j.
        (
          ServerAcceptsAuthKey(nc, ns, nk, shared_key1) @i ∧
          ClientAcceptsAuthKey(nc, ns, nk, shared_key2) @j ∧

          /* and no secret was leaked */
          ¬(∃ sk #r.   RegisteredSharedKey(sk) @r) ∧
          ¬(∃ sk #r.   CompromisedSharedKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r) ∧
          ¬(∃ skey #r. PostCompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    PostCompromisedNonce(n) @r) ∧
          ¬(∃ c #r.    PostCompromisedClientExponent(c) @r) ∧
          ¬(∃ s #r.    PostCompromisedServerExponent(s) @r)
        )
        ==>
        (
          /* then the authorization key is the same */
          ( shared_key1 = shared_key2 ) ∨
          
          /* 
           * or the server is actually running two different instances
           * of the protocol with the client
           */
          (
            ∃ #n1 #n2.
              ServerGeneratesNonce(ns) @n1 ∧
              ServerGeneratesNonce(ns) @n2 ∧
              ¬(#n1 = #n2)
          )
        )
    "
