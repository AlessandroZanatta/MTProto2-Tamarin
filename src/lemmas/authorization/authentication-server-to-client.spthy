
  /*
   * There is authentication of the server to the client (if the server
   * does not reuse its server nonce).
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtAuthServerToClient:
    "
      ∀ nc ns nk authKey #i.
        /* Whenever a client receives an ACK from the server */
        ClientReceivesAck(nc, ns, nk, authKey) @i ∧
        
        /* and no secret was leaked */
        ¬(∃ sk #r.   RegisteredAuthKey(sk) @r) ∧
        ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
        ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
        ¬(∃ n #r.    CompromisedNk(n) @r) ∧
        ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
        ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
        ¬(∃ s #r.    CompromisedServerExponent(s) @r) ∧
        ¬(∃ skey #r. PostCompromisedPrivateKey(skey) @r) ∧
        ¬(∃ n #r.    PostCompromisedNonce(n) @r) ∧
        ¬(∃ c #r.    PostCompromisedClientExponent(c) @r) ∧
        ¬(∃ s #r.    PostCompromisedServerExponent(s) @r)
        ==>
        (
          /* 
           * then there is a session matching it on the server
           *
           * Note: Trying to prove injectivity seems to make Tamarin use huge
           * amounts of RAM (~12-16 GB) in a very short period of time (~30/40 seconds).
           * Be careful if you uncomment the injectivity check.
           */
          ( 
            ∃ #j1.
            ServerAcceptsAuthKey(nc, ns, nk, authKey) @j1 
            // ∧
            // ¬(
            //   ∃ #j2.
            //     ServerAcceptsAuthKey(nc, ns, nk, authKey) @j2 ∧
            //     ¬(#j1 = #j2)
            // )
          ) ∨

          /* or the server has reused the same nonce */
          (
            ∃ #j1 #j2.
              ServerGeneratesNonce(ns) @j1 ∧
              ServerGeneratesNonce(ns) @j2 ∧
              ¬(#j1 = #j2)
          )
        )
    "
