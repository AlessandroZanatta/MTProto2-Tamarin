

  /*
   * TODO: this lemma actually holds. Is this an error in the model or what???
   *
   * Expected result: False
   * Estimated time: N/A
   */
  lemma LemmaRekeyingAuthentication_1:
    "
      ∀ exchangeID iUser1 iUser2 rUser1 rUser2 newKey #i #j.
        /* Whenever two users negotiate the same key in the same session */
        InitiatorHasNegotiatedNewKey(exchangeID, iUser1, rUser1, newKey) @i ∧
        ResponderHasNegotiatedNewKey(exchangeID, iUser2, rUser2, newKey) @j ∧

        /* and no secret was revealed */
        // ¬(∃ x #r. RegisteredSessionKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingInitiatorEphemeralKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingResponderEphemeralKey(x) @r)
        ==>
        (
          /* then there are actually only two users involved */
          iUser1 = iUser2 ∨
          iUser1 = rUser2 ∨
          rUser1 = iUser2 ∨
          rUser1 = rUser2
        )
    "


  /*
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaRekeyingAuthentication_2:
    "
      ∀ exchangeID1 exchangeID2 iUser rUser newKey #i #j.
        /* 
         * Whenever an honest initiator iUser accepts a new key with Bob in
         * a session, and an honest responder rUser accepts the same key with
         * Alice in another session
         */
        InitiatorHasNegotiatedNewKey(exchangeID1, iUser, 'Bob', newKey) @i ∧
        ResponderHasNegotiatedNewKey(exchangeID2, 'Alice', rUser, newKey) @j ∧
        
        /* and no secret was revealed */
        // ¬(∃ x #r. RegisteredSessionKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingInitiatorEphemeralKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingResponderEphemeralKey(x) @r)
        ==>
        (
          /* then the session is the same */
          exchangeID1 = exchangeID2 ∧

          /* and the initiator is Alice */
          iUser = 'Alice' ∧

          /* and the responder is Bob */
          rUser = 'Bob'
        )
    "

  /*
   * TODO: actual result if False! Find the problem
   *
   * Expected result: True
   * Estimated time: N/A
   */
  lemma LemmaRekeyingAuthentication_3:
    "
      ∀ exchangeID rUser newKey #i.
        /* 
         * Whenever an honest responder ends up accepting a new key after
         * a rekeying session exchangeID with 'Alice'
         */
        ResponderHasNegotiatedNewKey(exchangeID, 'Alice', rUser, newKey) @i ∧

        /* and no secret was revealed */
        // ¬(∃ x #r. RegisteredSessionKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingInitiatorEphemeralKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingResponderEphemeralKey(x) @r)
        ==>
        (
          /* 
           * then it was 'Alice' who started session exchangeID and computed
           * the new key
           */
          (
            ∃ #j1.
              InitiatorHasNegotiatedNewKey(exchangeID, 'Alice', rUser, newKey) @j1
              /* injectivity */
              // ∧ ¬(
              //   ∃ #j2.
              //     InitiatorHasNegotiatedNewKey(exchangeID, 'Alice', rUser, newKey) @j2 ∧
              //     ¬(#j1 = #j2)
              // )
          ) ∨

          /*
           * or rUser himself started session exchangeID with 'Alice' and his
           * messages were reflected back by the attacker in a parallel session
           * with the same exchange id
           */
          (
            ∃ #j1.
              InitiatorHasNegotiatedNewKey(exchangeID, rUser, 'Alice', newKey) @j1
              /* injectivity */
              // ∧ ¬(
              //   ∃ #j2.
              //     InitiatorHasNegotiatedNewKey(exchangeID, rUser, 'Alice', newKey) @j2 ∧
              //     ¬(#j1 = #j2)
              // )
          )
        )
    "

  /*
   * TODO: actual result if False! Find the problem
   *
   * Expected result: True
   * Estimated time: N/A
   */
//  lemma LemmaRekeyingAuthentication_4:
//    "
//      ∀ rID sender exchangeID iUser rUser newKey msg #i.
//
//        ClientReceivesMsgWithNewKey(rID, sender, exchangeID, 'Alice', rUser, newKey, msg) @i ∧
//
//        /* and no secret was revealed */
//        // ¬(∃ x #r. RegisteredSessionKey(x) @r) ∧
//        ¬(∃ x #r. CompromisedRekeyingInitiatorEphemeralKey(x) @r) ∧
//        ¬(∃ x #r. CompromisedRekeyingResponderEphemeralKey(x) @r)
//        ==>
//        (
//          ClientIni
//        )
//     "

  lemma Test:
    exists-trace
    "
      ∃ xID sender exchangeID iUser rUser newKey msg #i.
        ClientReceivesMsgWithNewKey(xID, sender, exchangeID, iUser, rUser, newKey, msg) @i ∧
        ¬(
          ∃ u1 u2 u3 u4 u5 u6 #u7.
            ClientSendsMsgWithNewKey(u1, u2, u3, u4, u5, u6, msg) @u7
        ) ∧
        
        ¬(∃ x #r. CompromisedRekeyingInitiatorEphemeralKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingResponderEphemeralKey(x) @r)
    "

  lemma Test2:
    exists-trace
    "
      ∃ exchangeID iUser rUser newKey #j.
        ResponderHasNegotiatedNewKey(exchangeID, iUser, rUser, newKey) @j ∧
        ¬(
          ∃ u1 u2 u3 u4 #u5.
            InitiatorSendsHalfKey(u1, u2, u3, u4) @u5
        ) ∧
        ¬(∃ x #r. CompromisedRekeyingInitiatorEphemeralKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingResponderEphemeralKey(x) @r)

    "

  lemma Test3:
    exists-trace
    "
      ∃ exchangeID iUser rUser newKey #j.
        InitiatorHasNegotiatedNewKey(exchangeID, iUser, rUser, newKey) @j ∧
        ¬(
          ∃ u1 u2 u3 u4 u5 #u6.
            ResponderSendsHalfKey(u1, u2, u3, u4, u5) @u6
        ) ∧
        ¬(∃ x #r. CompromisedRekeyingInitiatorEphemeralKey(x) @r) ∧
        ¬(∃ x #r. CompromisedRekeyingResponderEphemeralKey(x) @r)
    "
