
/*
 * MTProto 2.0: Encryption scheme - Part I (cloud chats)
 *
 * See: https://core.telegram.org/mtproto/description
 */

  /*
   * Encodes the message, then outputs it.
   */
//  rule EncodeCloudChatMsg:
//    let
//      mk        = msgKey(authKey, msg)
//      encrypted = AES_IGE_enc(msg, kdfKey(authKey, mk), kdfIV(authKey, mk))
//      final_msg = <keyID(authKey), mk, encrypted>
//    in
//      [ RequestEncodeCloudChatMsg(msg, authKey) ]
//    -->
//      [ Out(final_msg) ]

  /*
   * Allows the creation of a decode request from a server.
   *
   * Uses a fresh msgID generated by the client to match the correct
   * decoding request. Note that the encrypting process resides on the
   * server, hence it makes sense to be able to recognize the single request.
   */
  rule ServerDecodeCloudChatMsg:
    let
      encoded_msg = <kID, mk, c>
    in
      [
        RequestServerDecodeCloudChatMsg(~msgID, encoded_msg),
        !AuthKeyServer(kID, authKey)
      ]
    -->
      [
        RequestServerDecodeCloudChatMsg_internal(~msgID, authKey, <kID, mk, c>)
      ]

  /*
   * For internal use only. TODO: may be possible to do in a single rule.
   */
  rule ServerDecodeCloudChatMsg_internal:
    let
      c  = AES_IGE_enc(m, kdfKey(authKey, mk), kdfIV(authKey, mk))
      mk = msgKey(authKey, m)
    in
      [ RequestServerDecodeCloudChatMsg_internal(~msgID, authKey, <kID, mk, c>) ]
    -->
      [ ServerDecodedCloudChatMsg(~msgID, m, authKey) ]
  
  /*
   * Allows the creation of a decode request for a client.
   *
   * Same reasoning as above applies to msgID.
   */
  rule ClientDecodeCloudChatMsg:
    let
      kID          = keyID(authKey)
      encoded_msg  = <kID, mk, c>
    in
      [ RequestClientDecodeCloudChatMsg(msgID, encoded_msg, authKey) ]
    -->
      [ RequestClientDecodeCloudChatMsg_internal(msgID, authKey, <kID, mk, c>) ]
  
  rule ClientDecodedCloudChatMsg_internal:
    let
      c = AES_IGE_enc(m, kdfKey(authKey, mk), kdfIV(authKey, mk))
      mk = msgKey(authKey, m)
    in
      [ RequestClientDecodeCloudChatMsg_internal(msgID, authKey, <kID, mk, c>) ]
    -->
      [ ClientDecodedCloudChatMsg(msgID, m) ]


  /*
   * Allows the attacker to create an encode/decode request for a given
   * msg and authKey.
   */
  rule AttackerEncodeCloudChatMsg:
      [ In(<msg, authKey>) ]
    -->
      [ RequestEncodeCloudChatMsg(msg, authKey) ]

  rule AttackerClientDecodeCloudChatMsg:
      [ In(<msgID, enc_msg, authKey>) ]
    -->
      [ RequestClientDecodeCloudChatMsg(msgID, enc_msg, authKey) ]
  
  rule AttackerGetDecodedCloudChatMsgResult:
      [ In(msgID), ClientDecodedCloudChatMsg(msgID, m) ]
    -->
      [ Out(m) ]


  // TODO: Server's decode is not modeled as it uses knowledge that is meant
  // to be known by honest server only (!AuthKeyServer facts).
  // Check if this is correct.
