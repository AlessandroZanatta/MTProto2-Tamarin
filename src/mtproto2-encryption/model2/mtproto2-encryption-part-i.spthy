
/*
 * MTProto 2.0: Encryption scheme - Part I (cloud chats)
 *
 * See: https://core.telegram.org/mtproto/description
 */

  /*
   * Allows the creation of an encode request.
   *
   * Uses a fresh msgID generated by the client to match the correct
   * encoding request. Note that the encrypting process resides on the
   * client, hence it makes sense to be able to recognize the single request.
   */
  rule EncodeCloudChatMsg:
    let
      mk        = msgKey(authKey, msg)
      encrypted = AES_IGE_enc(msg, kdfKey(authKey, mk), kdfIV(authKey, mk))
      final_msg = MTPROTO(keyID(authKey), mk, encrypted)
    in
      [ RequestEncodeCloudChatMsg(msgID, msg, authKey) ]
    -->
      [ EncodedCloudChatMsg(msgID, final_msg) ]

  /*
   * Allows the creation of a decode request from a server.
   *
   * As for the EncodeCloudChatMsg rule, this uses a fresh msgID.
   * Same reasoning applies here.
   */
  rule ServerDecodeCloudChatMsg:
    let
      encoded_msg = MTPROTO(kID, mk, c)
    in
      [
        RequestServerDecodeCloudChatMsg(msgID, encoded_msg),
        !AuthKeyServer(kID, authKey)
      ]
    -->
      [
        RequestServerDecodeCloudChatMsg_internal(msgID, authKey, <kID, mk, c>)
      ]

  /*
   * For internal use only.
   */
  rule ServerDecodeCloudChatMsg_internal:
    let
      c  = AES_IGE_enc(m, kdfKey(authKey, mk), kdfIV(authKey, mk))
      mk = msgKey(authKey, m)
    in
      [ RequestServerDecodeCloudChatMsg_internal(msgID, authKey, <kID, mk, c>) ]
    -->
      [ ServerDecodedCloudChatMsg(msgID, m, authKey) ]
  
  /*
   * Allows the creation of a decode request for a client.
   *
   * Same reasoning as above applies to msgID.
   */
  rule ClientDecodeCloudChatMsg:
    let
      encoded_msg  = MTPROTO(keyID(authKey), mk, c)
      c            = AES_IGE_enc(m, kdfKey(authKey, mk), kdfIV(authKey, mk))
      mk           = msgKey(authKey, m)
    in
      [ 
        RequestClientDecodeCloudChatMsg(msgID, encoded_msg, authKey)
      ]
    -->
      [
        ClientDecodedCloudChatMsg(msgID, m)
      ]

  /*
   * Allows the attacker to create an encode/decode request for a given
   * msg and authKey.
   */
  rule AttackerEncodeCloudChatMsg:
      [ In(<msgID, msg, authKey>) ]
    -->
      [ RequestEncodeCloudChatMsg(msgID, msg, authKey) ]
  
  rule AttackerGetEncodedCloudChatMsgResult:
      [ In(msgID), EncodedCloudChatMsg(msgID, encoded_msg) ]
    -->
      [ Out(encoded_msg) ]

  rule AttackerClientDecodeCloudChatMsg:
      [ In(<msgID, enc_msg, authKey>) ]
    -->
      [ RequestClientDecodeCloudChatMsg(msgID, enc_msg, authKey) ]
  
  rule AttackerGetDecodedCloudChatMsgResult:
      [ In(msgID), ClientDecodedCloudChatMsg(msgID, m) ]
    -->
      [ Out(m) ]


  // TODO: Server's decode is not modeled as it uses knowledge that is meant
  // to be known by honest server only (!AuthKeyServer facts).
  // Check if this is correct.
