theory mtproto2

begin
  builtins: diffie-hellman, asymmetric-encryption

/*****************************************************************/
/* Boolean types                                                 */
/*****************************************************************/

  functions:
    true/0,
    false/0


/*****************************************************************/
/* Diffie-Hellman with small/bad subgroup attacks.               */
/* See Bhargavan, Blanchet and Kobeissi, 2017.                   */
/*                                                               */
/* WEAK, STRONG and BAD are defined as functions because Tamarin */
/* does not allow the usage of public contants in equations.     */
/*****************************************************************/
 
  /* 
   * Public constants:
   *  - ALLOW_WEAK_DH
   *  - DISALLOW_WEAK_DH
   */

/*****************************************************************/
/* Hash functions, including functions with collisions.          */
/*                                                               */
/* WEAK_HASH, COLLISION and GOOD_HASH are defined as functions   */
/* because Tamarin does not allow the usage of public contants   */
/* in equations.                                                 */
/*****************************************************************/
  
  functions: 
    hash/2,      // Hash function with collisions
    hashIdeal/1, // Perfect hash function
    WEAK_HASH/0,
    COLLISION/0,
    GOOD_HASH/0
  
  equations:
    hash(WEAK_HASH, x) = COLLISION,   // Collision
    hash(GOOD_HASH, x) = hashIdeal(x) // Perfect hash

/*****************************************************************/
/* Other convenience functions                                   */
/*****************************************************************/

//  restriction RestrictionChoosePrincipal:
//    "
//      ∀ X Y Z #i.
//        ChoosePrincipal(X, Y, Z) @i ==> ((X = Y) ∨ (X = Z))
//    "

//  /* Checks if weak DH is allowed or DH parameters are not weak */
//  restriction CheckWeakDHAllowed:
//    "
//      ∀ p g half allowed #i.
//        WeakDHAllowed(p, g, half, allowed) @i
//        ==>
//        (
//          allowed = 'ALLOW_WEAK_DH' ∨
//          (¬(p = WEAK_MODULO) ∧ ¬(g = BAD_ELEMENT) ∧ ¬(half = BAD_ELEMENT))
//        )
//    "


/*****************************************************************/
/* MTProto 2.0's encryption schema: common definitions           */
/*****************************************************************/

///* 
// * Constructor for an MTProto message 
// * See: https://core.telegram.org/mtproto/description#encrypted-message
// */
//  functions: 
//    /*
//     * Arguments: 
//     *  - an hash value
//     *  - a msg key (128-bit MACs computed from the message and the shared key)
//     *  - a ciphertext
//     * 
//     * Output: an MTProto message
//     */
//    MTPROTO/3,
//    MTPROTO_1/1,
//    MTPROTO_3/1,
//    MTPROTO_2/1
//
//  equations:
//    MTPROTO_1(MTPROTO(a, b, c)) = a,
//    MTPROTO_2(MTPROTO(a, b, c)) = b,
//    MTPROTO_3(MTPROTO(a, b, c)) = c

/*
 * In MTProto, this function computes the 64 lower-order bits of the
 * SHA-1 hash of the input authorization key or session key.
 */
  functions: 
    /*
     * Arguments: 
     *  - a shared key
     *
     * Output: an hash value
     */
    keyID/1

/*
 * In MTProto, the message key is computed as the middle 128 bits of the
 * SHA-256 hash of the concatenation of a fragment of the authorization key
 * and the plaintext, as follows:
 *
 *   msgKey(k,m) := SHA256( k[88+x,120+x) | m | random padding )[8,24)
 *
 * where x=0 for messages from client to server and x=8 for messages from
 * server to client.
 */
  functions:
    /*
     * Arguments:
     *  - a shared key
     *  - a plaintext
     *
     * Output: a msg key (as defined above, 128-bit MACs)
     */
    msgKey/2

  /* Fingerprint of a session key */
  functions: fps/1


/*
 * An ephemeral key and an initialization vector are derived from the
 * authorization key and the message key through a mix of SHA-256, 
 * substring, and concatenation operations.
 */
  functions:
    /* 
     * Arguments:
     *  - a shared key
     *  - a msg key
     *
     * Output: a shared key
     */
    kdfKey/2,

    /*
     * Arguments:
     *  - a shared key
     *  - a msg key
     *
     * Output: a nonce
     */
    kdfIV/2


/*****************************************************************/
/* Asymmetric encryption                                         */
/*****************************************************************/

/* 
 * Deterministic encryption is defined using the 
 * builtin 'asymmetric-encryption'.
 */

/* Probabilistic encryption */
  // functions: RSA_enc/3
  // equations: RSA_dec(internal_RSA_enc(plain, pk(k), r), k) = m

    
/*****************************************************************/
/* Symmetric encryption                                          */
/*****************************************************************/

/*
 * All symmetric encryption in MTProto 2.0 is performed using
 * AES in IGE mode. IGE is described as follows:
 *                  yᵢ = Fₖ(xᵢ ⊗ yᵢ₋₁) ⊗ xᵢ₋₁
 * IGE requires a pair (x₀,y₀) for the first output block, which
 * basically corresponds to the traditional IV.
 *
 * This implementation treats IGE as a perfect primitive, following
 * the usual symbolic approach. A better description of IGE might be
 * achieved (TODO).
 */

  functions: senc/3, sdec/3, genKey/2, genIV/2, keyID/1
  equations: sdec(
      senc(m, 
          genKey(ns, nk), 
          genIV(ns, nk)
      ), 
      genKey(ns, nk), 
      genIV(ns, nk)
  ) = m

/* 
 * Malleability of the ciphertext is *not* modeled.
 * TODO
 */
/*
 * MTProto 2.0: Secret Chats
 *
 * Model for the protocol used in secret chats.
 *
 * See: https://core.telegram.org/api/end-to-end
 */

/*
 * An encrypted chat's messages pass through the server, 
 * who should act as a forwarder. 
 *
 * Each message is encrypted twice: first, with the session key
 * shared only by the two communicating parties; then, with the long-term
 * authorization key of one of the clients.
 *
 * NOTE: in the model the above described double encryption is NOT modeled. This means
 * that authorization keys are considered inherently secure.
 *
 * When the server receives a message from a client A destined to 
 * client B, it decrypts the message using A's long-term shared key
 * (thus retrieving the payload encrypted with the clients's session key)
 * then re-encrypt the message with B's long-term key and sends it to B.
 */

  rule SecretChatInitiator_1 [color=#41A9A9]:
      [
        In(<iUser, rUser>),

        /* Ephemeral key */
        Fr(~i),

        /* Long-term key shared with the server */
        !AuthKeyClient(iUser, $Server, authKey)
      ]
    --[
        ChoosePrincipal(iUser, $Alice, $Bob), 
        /*
         * Client starts a run of the secret chat protocol,
         * identified by the ephemeral key ~i
         */
        InitiatorRequestsDHConfig(~i, iUser)
      ]->
      [ 
        !SecretChatInitiatorEphemeralKey(~i),
        SecretChatInitiatorState_1(iUser, rUser, ~i, authKey),
        Out('GET_DH_CONFIG')
      ]

  rule SecretChatInitiator_1_1 [color=#41A9A9]:
    let
      g_i = 'g' ^ ~i
    in
      [
        SecretChatInitiatorState_1(iUser, rUser, ~i, authKey),
        
        In(<'DH_CONFIG', 'g'>),

        /* Chat identifier */
        Fr(~chatID)
      ]
    --[
        /*
         * Chat's initiator sends a request to start an encrypted chat
         * with another party with chat identified ~chatID
         */
        InitiatorRequestsEncryptedChat(~i, ~chatID, iUser, rUser)
      ]->
      [
        SecretChatInitiatorState_1_1(iUser, rUser, ~i, ~chatID, authKey),
        Out(<'REQI', iUser, rUser, ~chatID, g_i>)
      ]

  rule SecretChatResponder_2 [color=#4C6085]:
      [
        In(rUser),

        /* Ephemeral key */
        Fr(~r),

        /* Long-term key shared with the server */
        !AuthKeyClient(rUser, $Server, authKey)
      ]
    --[
        ChoosePrincipal(rUser, $Alice, $Bob)
      ]->
      [
        SecretChatResponderState_2(rUser, ~r, authKey),
        !SecretChatResponderEphemeralKey(~r)
      ]

  rule SecretChatResponder_2_1 [color=#4C6085]:
      [
        SecretChatResponderState_2(rUser, ~r, authKey),
        
        /* Secret chat initiator request */
        In(<'REQI', iUser, rUser, chatID, g_i>)
      ]
    --[
        /*
         * Client (responder) has received a request to start a chat
         * in chat session ~r with half key g_i
         */
        ResponderReceivesRequestForEncryptedChat(~r, chatID, iUser, rUser, g_i),

        /*
         * Client (responder) has accepted to start a chat session ~r.
         */
        ResponderAcceptsInitiator(~r, chatID, iUser, rUser)
      ]->
      [
        SecretChatResponderState_2_1(iUser, rUser, ~r, chatID, authKey, g_i),
        Out(<'CHAT_ACCEPTED', chatID>)
      ]


  rule SecretChatResponder_2_2 [color=#4C6085]:
    let
      /* Pattern matching for the incoming half key */
      g_i        = 'g' ^ ~i
    
      /* Responder half key and full key */
      g_r        = 'g' ^ ~r
      sessionKey = g_i ^ ~r
      fp         = fps(sessionKey)
    in
      [
        SecretChatResponderState_2_1(iUser, rUser, ~r, chatID, authKey, g_i),
        In(<'DH_CONFIG', 'g'>)
      ]
    --[
        /*
         * Responder has computed session key sessionKey in chat session ~r
         * started by initiator
         */
        ResponderHasSessionKeyForEncryptedChat(~r, chatID, iUser, rUser, sessionKey)
      ]->
      [ 
        SecretChatResponderState_2_2(iUser, rUser, ~r, chatID, authKey, g_i, sessionKey),
        Out(<'ACCEPTR', chatID, iUser, rUser, g_r, fp>),
        !QR(~r, rUser, iUser, sessionKey)
      ]

  rule SecretChatInitiator_3 [color=#41A9A9]:
    let
      g_r = 'g' ^ ~r
      sessionKey = g_r ^ ~i
    in
      [
        SecretChatInitiatorState_1_1(iUser, rUser, ~i, ~chatID, authKey),
        In(<'ACCEPTR', ~chatID, iUser, rUser, g_r, fp>)
      ]
    --[
        /*
         * The session key received in chat session ~i matches/does not match
         * the session key's fingerprint.
         *
         * Lemmas using this fact are supposted to check if third and fourth
         * arguments are actually the same (matches) or not (does not match).
         */
        SessionKeyFingerprintMatches(~i, ~chatID, iUser, rUser, fp, fps(sessionKey)),

        /*
         * Inititator has computed sessione key sessionKey in chat session ~i
         */
        InitiatorHasSessionKeyForEncryptedChat(~i, ~chatID, iUser, rUser, sessionKey)
      ]->
      [
        SecretChatInitiatorState_3(iUser, rUser, ~i, ~chatID, authKey, g_r, sessionKey),
        
        /*
         * Out-of-band comparison of the generated session key is 
         * a crucial step to avoid MitM attacks. This step is 
         * delegated to two rules, one that performs this step 
         * correctly and one that doesn't. 
         *
         * This way we can model a user's misbehaviour.
         */
        !QR(~i, iUser, rUser, sessionKey)
      ]

  rule SecretChatResponder_4 [color=#4C6085]:
      [
        SecretChatResponderState_2_2(iUser, rUser, ~r, chatID, authKey, g_i, sessionKey),
        !QROK(~r, rUser, iUser, sessionKey)
      ]
    --[
        /*
         * Responder has completed session ~r of the secret chat protocol
         * negotiating with initiator a shared key sessionKey
         */
        ResponderAcceptsEncryptedChat(~r, chatID, iUser, rUser, sessionKey)
      ]->
      [
        /* End of the protocol. Used for the rekeying protocol. */
        !SecretChatClient(rUser, iUser, rUser, ~r, chatID, sessionKey, authKey)
      ]

  rule SecretChatInitiator_5 [color=#41A9A9]:
      [
        SecretChatInitiatorState_3(iUser, rUser, ~i, ~chatID, authKey, g_r, sessionKey),
        !QROK(~i, iUser, rUser, sessionKey)
      ]
    --[
        /*
         * Chat initiator has completed session ~i of the secret chat protocol
         * negotiating with responder a shared key sessionKey
         */
        InitiatorAcceptsEncryptedChat(~i, ~chatID, iUser, rUser, sessionKey)
      ]->
      [
        !SecretChatClient(iUser, iUser, rUser, ~i, ~chatID, sessionKey, authKey)
      ]

/*****************************************************************/
/* QR verification rules                                         */
/*****************************************************************/

  rule PerformOutOfBandKeyComparison [color=#99C24D]:
      [ 
        !QR(aID, aUser, bUser, sessionKey),
        !QR(bID, bUser, aUser, sessionKey)
      ]
    --[ 
        /* Rule out the possibility of sessions of a client with itself */
        NotEq(aUser, bUser),

        OutOfBandKeyComparisonSucceeded(aID, aUser, bUser, sessionKey),
        OutOfBandKeyComparisonSucceeded(bID, bUser, aUser, sessionKey)
      ]->
      [
        !QROK(aID, aUser, bUser, sessionKey),
        !QROK(aID, bUser, aUser, sessionKey)
      ]

  rule SkipOutOfBandKeyComparison [color=#99C24D]:
      [ !QR(aID, aUser, bUser, sessionKey) ]
    --[
        OutOfBandKeyComparisonSkipped(aID, aUser, sessionKey)
      ]->
      [ !QROK(aID, aUser, bUser, sessionKey) ]


/*****************************************************************/
/* Secret chat message sending/receiving rules                   */
/*****************************************************************/

  rule SecretChatSend [color=#0088CC]:
    let
      mk  = msgKey(sessionKey, ~m)
      key = kdfKey(sessionKey, mk)
      iv  = kdfIV(sessionKey, mk)

      c   = <keyID(sessionKey), mk, senc(~m, key, iv)>
    in
      [ 
        !SecretChatClient(X, iUser, rUser, xID, chatID, sessionKey, authKey),
        Fr(~m)
      ]
    --[
        ClientSendsSecretChatMsg(chatID, X, iUser, rUser, sessionKey, ~m)
      ]->
      [
        Out(c)
      ]

  rule SecretChatReceive [color=#0088CC]:
    let
      mk  = msgKey(sessionKey, ~m)
      key = kdfKey(sessionKey, mk)
      iv  = kdfIV(sessionKey, mk)

      c   = <keyID(sessionKey), mk, senc(~m, key, iv)>
    in
      [
        !SecretChatClient(X, iUser, rUser, xID, chatID, sessionKey, authKey),
        In(c)
      ]
    --[ ClientReceivesSecretChatMsg(chatID, X, iUser, rUser, sessionKey, ~m) ]->
      []

/*****************************************************************/
/* Other convenience functions                                   */
/*****************************************************************/

  rule GenerateDHConfig [color=#99C24D]:
      []
    -->
      [ Out(<'DH_CONFIG', 'g'>) ]

  /*
   * In the secret chat threat model the authorization key is considered
   * to be secure (i.e. not considered part of the threat model).
   *///  restriction RestrictionChoosePrincipal:
//    "
//      ∀ X Y Z #i.
//        ChoosePrincipal(X, Y, Z) @i ==> ((X = Y) ∨ (X = Z))
//    "
  rule GenerateAuthKey [color=#99C24D]:
    let
      authKey = 'g' ^ ~a ^ ~b
    in
      [ Fr(~a), Fr(~b) ]
    -->
      [ !AuthKeyClient($X, $Server, authKey) ]

/*****************************************************************/
/* Attacker capabilities                                         */
/*****************************************************************/

  rule CompromiseSecretChatInitiatorEphemeralKey [color=#FE4A49]:
      [ !SecretChatInitiatorEphemeralKey(~i) ]
    --[ CompromisedSecretChatInitiatorEphemeralKey(~i) ]->
      [ Out(~i) ]

  rule CompromiseSecretChatResponderEphemeralKey [color=#FE4A49]:
      [ !SecretChatResponderEphemeralKey(~r) ]
    --[ CompromisedSecretChatResponderEphemeralKey(~r) ]->
      [ Out(~r) ]

/*****************************************************************/
/* Other utilities                                               */
/*****************************************************************/
 
  /*
   * Public names cannot be used in lemmas. This rule
   * allows to test for equality on $Alice and $Bob 
   * public names.
   *
   * NOTE: this works because this is the only rule that
   * can create the AliceAndBob fact.
   */
  rule AliceAndBob [color=#99C24D]:
      []
    --[ AliceAndBob($Alice, $Bob) ]->
      []

  restriction RestrictionNotEqual:
    "
      ∀ x y #i.
        NotEq(x, y) @i ==> ¬(x = y)
    "

  restriction RestrictionChoosePrincipal:
    "
      ∀ X Y Z #i.
        ChoosePrincipal(X, Y, Z) @i ==> ((X = Y) ∨ (X = Z))
    "


  /*
   * If a client X (one of I or R) receives a message m encrypted 
   * with a session key sessionKey in a chat session chatID, then 
   * such message was sent by the other party, unless they skip some
   *  mandatory check.
   *
   * NOTE: we cannot force chatID1 = chatID2, because the chat session 
   * identifier is available to the server/attacker, who is free to 
   * change it when forwarding messages.
   *
   * Expected result: True
   * Estimated time: ~1 minute
   */
  lemma LemmaSecretChatAuthentication1:
    "
      ∀ chatID1 X iUser rUser msg sessionKey #i.

        /* Whenever a client received a secret chat message */
        ClientReceivesSecretChatMsg(chatID1, X, iUser, rUser, sessionKey, msg) @i ∧

        /* and no secret was leaked */
        ¬(∃ z #r. CompromisedSecretChatInitiatorEphemeralKey(z) @r) ∧
        ¬(∃ z #r. CompromisedSecretChatResponderEphemeralKey(z) @r)
        ==>
        (
          /* then it was sent by another (honest) client */
          (∃ Y chatID2 #r. 
            ClientSendsSecretChatMsg(chatID2, Y, iUser, rUser, sessionKey, msg) @r) ∨
          (∃ Y chatID2 #r. 
            ClientSendsSecretChatMsg(chatID2, Y, rUser, iUser, sessionKey, msg) @r) ∨

          /* or clients involved had skipped the QR validation */
          (
            ∃ Y xID yID #r1 #r2. 
              OutOfBandKeyComparisonSkipped(xID, X, sessionKey) @r1 ∧
              OutOfBandKeyComparisonSkipped(yID, Y, sessionKey) @r2
          )
        )
    "


  /*
   * If an (honest) initiator negotiates a key sessionKey and an
   * (honest) responder accepts a key sessionKey, then the initiator is
   * Alice and the responder is Bob.
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaSecretChatAuthentication2:
    "
      ∀ aID bID chatID iUser rUser sessionKey Alice Bob #i #j #ab.
        AliceAndBob(Alice, Bob) @ab ∧

        /* 
         * Whenever the initiator has accepted a chat with Bob and
         * the responder has accepted a chat with Alice (both in the
         * same session and with the same key)
         */
        InitiatorAcceptsEncryptedChat(aID, chatID, iUser, Bob, sessionKey) @i ∧
        ResponderAcceptsEncryptedChat(bID, chatID, Alice, rUser, sessionKey) @j ∧

        /* and no secret was leaked */
        ¬(∃ z #r. CompromisedSecretChatInitiatorEphemeralKey(z) @r) ∧
        ¬(∃ z #r. CompromisedSecretChatResponderEphemeralKey(z) @r)
        ==>
        (
          /* then the initiator is Alice and the responder is Bob */
          (
            iUser = Alice ∧ rUser = Bob
          ) ∨

          /* or clients skipped the QR validation */
          (
            ∃ #r1 #r2. 
              OutOfBandKeyComparisonSkipped(aID, iUser, sessionKey) @r1 ∧
              OutOfBandKeyComparisonSkipped(bID, rUser, sessionKey) @r2
          )
        )
    "


  /*
   * Variant of the above lemma.
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaSecretChatAuthentication3:
    "
      ∀ aID bID chatID iUser rUser sessionKey Alice Bob #i #j #ab.
        AliceAndBob(Alice, Bob) @ab ∧

        /* 
         * Whenever the initiator has accepted a chat with Bob and
         * the responder has accepted a chat with Alice (both in the
         * same session and with the same key)
         */
        InitiatorAcceptsEncryptedChat(aID, chatID, iUser, Bob, sessionKey) @i ∧
        ResponderAcceptsEncryptedChat(bID, chatID, Alice, rUser, sessionKey) @j ∧

        /* and no secret was leaked */
        ¬(∃ z #r. CompromisedSecretChatInitiatorEphemeralKey(z) @r) ∧
        ¬(∃ z #r. CompromisedSecretChatResponderEphemeralKey(z) @r)
        ==>
        (
          /* then the initiator is Alice and the responder is Bob */
          (
            iUser = Alice ∧ rUser = Bob
          ) ∨
          (
            ∃ x1 x2 #r. 
              OutOfBandKeyComparisonSkipped(x1, x2, sessionKey) @r
          )
        )
    "


  /*
   * More generally, if an (honest) initiator iUser1 negotiates a 
   * session key sessionKey to chat with rUser1, and an (honest) 
   * responder rUser2 negotiates the same key sessionKey to chat
   * with iUser2, then there are only two parties involved, unless 
   * the clients skip the out-of-band validation of sessionKey.
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaSecretChatAuthentication4:
    "
      ∀ aID bID chatID1 chatID2 iUser1 iUser2 rUser1 rUser2 sessionKey #i #j.

        /*
         * Whenever an initiator and responder have both accepted the same
         * session key sessionKey
         */
        InitiatorAcceptsEncryptedChat(aID, chatID1, iUser1, rUser1, sessionKey) @i ∧
        ResponderAcceptsEncryptedChat(bID, chatID2, iUser2, rUser2, sessionKey) @j ∧

        /* and no secret was leaked */
        ¬(∃ z #r. CompromisedSecretChatInitiatorEphemeralKey(z) @r) ∧
        ¬(∃ z #r. CompromisedSecretChatResponderEphemeralKey(z) @r)
        ==>
        (
          /* 
           * then these two clients are actually the two involved in the
           * session key sessionKey negotiation 
           */
          ( iUser1 = iUser2 ∧ rUser1 = rUser2 ) ∨

          /* or they skipped QR validation */
          (
            ∃ x1 x2 #r. 
              OutOfBandKeyComparisonSkipped(x1, x2, sessionKey) @r
          )
        )
    "


  /*
   * If the clients do not necessarily validate their keys, then the above does
   * not hold. In fact, I, I', R, and R' may be all different (even if the key is
   * the same!).
   */
  lemma LemmaSecretChatAuthentication5:
    "
      ∀ aID bID chatID iUser1 iUser2 rUser1 rUser2 sessionKey #i #j.

        /*
         * Whenever an initiator and responder have both accepted the same
         * session key sessionKey in the same session
         */
        InitiatorAcceptsEncryptedChat(aID, chatID, iUser1, rUser1, sessionKey) @i ∧
        ResponderAcceptsEncryptedChat(bID, chatID, iUser2, rUser2, sessionKey) @j ∧
        
        /* and no secret was leaked */
        ¬(∃ z #r. CompromisedSecretChatInitiatorEphemeralKey(z) @r) ∧
        ¬(∃ z #r. CompromisedSecretChatResponderEphemeralKey(z) @r)
        ==>
        (
          iUser1 = iUser2 ∨
          rUser1 = rUser2 ∨
          iUser1 = rUser2 ∨
          rUser1 = iUser2
        )
    "


  /*
   * If client X (which is one of iUser or rUser) sends message in a 
   * secret chat session chatID initiated by iUser with responder 
   * rUser and the attacker learns the plaintext, then some parties 
   * did not perform their mandatory checks.
   *
   * Note that iUser or rUser may be played by the attacker.
   */
  lemma LemmaSecretChatSecrecy:
    "
      ∀ chatID X iUser rUser sessionKey msg #i #j.
        /* Whenever the client sends a secret chat message msg */
        ClientSendsSecretChatMsg(chatID, X, iUser, rUser, sessionKey, msg) @i ∧
        
        /* but the attacker nows it */
        K(msg) @j ∧

        /* and no secret was leaked */
        ¬(∃ z #r. CompromisedSecretChatInitiatorEphemeralKey(z) @r) ∧
        ¬(∃ z #r. CompromisedSecretChatResponderEphemeralKey(z) @r)
        ==>
        (
          /* then clients skipped the QR validation */
          ∃ a #r. OutOfBandKeyComparisonSkipped(a, X, sessionKey) @r
        )

    "

end
