theory mtproto2

begin
  builtins: diffie-hellman, asymmetric-encryption

/*****************************************************************/
/* Boolean types                                                 */
/*****************************************************************/

  functions:
    true/0,
    false/0


/*****************************************************************/
/* Diffie-Hellman with small/bad subgroup attacks.               */
/* See Bhargavan, Blanchet and Kobeissi, 2017.                   */
/*                                                               */
/* WEAK, STRONG and BAD are defined as functions because Tamarin */
/* does not allow the usage of public contants in equations.     */
/*****************************************************************/
 
  /* 
   * Public constants:
   *  - ALLOW_WEAK_DH
   *  - DISALLOW_WEAK_DH
   */

/*****************************************************************/
/* Hash functions, including functions with collisions.          */
/*                                                               */
/* WEAK_HASH, COLLISION and GOOD_HASH are defined as functions   */
/* because Tamarin does not allow the usage of public contants   */
/* in equations.                                                 */
/*****************************************************************/
  
  functions: 
    hash/2,      // Hash function with collisions
    hashIdeal/1, // Perfect hash function
    WEAK_HASH/0,
    COLLISION/0,
    GOOD_HASH/0
  
  equations:
    hash(WEAK_HASH, x) = COLLISION,   // Collision
    hash(GOOD_HASH, x) = hashIdeal(x) // Perfect hash

/*****************************************************************/
/* Other convenience functions                                   */
/*****************************************************************/

//  restriction RestrictionChoosePrincipal:
//    "
//      ∀ X Y Z #i.
//        ChoosePrincipal(X, Y, Z) @i ==> ((X = Y) ∨ (X = Z))
//    "

//  /* Checks if weak DH is allowed or DH parameters are not weak */
//  restriction CheckWeakDHAllowed:
//    "
//      ∀ p g half allowed #i.
//        WeakDHAllowed(p, g, half, allowed) @i
//        ==>
//        (
//          allowed = 'ALLOW_WEAK_DH' ∨
//          (¬(p = WEAK_MODULO) ∧ ¬(g = BAD_ELEMENT) ∧ ¬(half = BAD_ELEMENT))
//        )
//    "


/*****************************************************************/
/* MTProto 2.0's encryption schema: common definitions           */
/*****************************************************************/

///* 
// * Constructor for an MTProto message 
// * See: https://core.telegram.org/mtproto/description#encrypted-message
// */
//  functions: 
//    /*
//     * Arguments: 
//     *  - an hash value
//     *  - a msg key (128-bit MACs computed from the message and the shared key)
//     *  - a ciphertext
//     * 
//     * Output: an MTProto message
//     */
//    MTPROTO/3,
//    MTPROTO_1/1,
//    MTPROTO_3/1,
//    MTPROTO_2/1
//
//  equations:
//    MTPROTO_1(MTPROTO(a, b, c)) = a,
//    MTPROTO_2(MTPROTO(a, b, c)) = b,
//    MTPROTO_3(MTPROTO(a, b, c)) = c

/*
 * In MTProto, this function computes the 64 lower-order bits of the
 * SHA-1 hash of the input authorization key or session key.
 */
  functions: 
    /*
     * Arguments: 
     *  - a shared key
     *
     * Output: an hash value
     */
    keyID/1

/*
 * In MTProto, the message key is computed as the middle 128 bits of the
 * SHA-256 hash of the concatenation of a fragment of the authorization key
 * and the plaintext, as follows:
 *
 *   msgKey(k,m) := SHA256( k[88+x,120+x) | m | random padding )[8,24)
 *
 * where x=0 for messages from client to server and x=8 for messages from
 * server to client.
 */
  functions:
    /*
     * Arguments:
     *  - a shared key
     *  - a plaintext
     *
     * Output: a msg key (as defined above, 128-bit MACs)
     */
    msgKey/2

  /* Fingerprint of a session key */
  functions: fps/1


/*
 * An ephemeral key and an initialization vector are derived from the
 * authorization key and the message key through a mix of SHA-256, 
 * substring, and concatenation operations.
 */
  functions:
    /* 
     * Arguments:
     *  - a shared key
     *  - a msg key
     *
     * Output: a shared key
     */
    kdfKey/2,

    /*
     * Arguments:
     *  - a shared key
     *  - a msg key
     *
     * Output: a nonce
     */
    kdfIV/2


/*****************************************************************/
/* Asymmetric encryption                                         */
/*****************************************************************/

/* 
 * Deterministic encryption is defined using the 
 * builtin 'asymmetric-encryption'.
 */

/* Probabilistic encryption */
  // functions: RSA_enc/3
  // equations: RSA_dec(internal_RSA_enc(plain, pk(k), r), k) = m

    
/*****************************************************************/
/* Symmetric encryption                                          */
/*****************************************************************/

/*
 * All symmetric encryption in MTProto 2.0 is performed using
 * AES in IGE mode. IGE is described as follows:
 *                  yᵢ = Fₖ(xᵢ ⊗ yᵢ₋₁) ⊗ xᵢ₋₁
 * IGE requires a pair (x₀,y₀) for the first output block, which
 * basically corresponds to the traditional IV.
 *
 * This implementation treats IGE as a perfect primitive, following
 * the usual symbolic approach. A better description of IGE might be
 * achieved (TODO).
 */

  functions: senc/3, sdec/3, genKey/2, genIV/2, keyID/1
  equations: sdec(
      senc(m, 
          genKey(ns, nk), 
          genIV(ns, nk)
      ), 
      genKey(ns, nk), 
      genIV(ns, nk)
  ) = m

/* 
 * Malleability of the ciphertext is *not* modeled.
 * TODO
 */

  /* Compute the fingerprint of a server's public key */
  functions:
    /*
     * Arguments:
     *  - a (server's ) public key
     *
     * Output: the key's fingerprint, which is basically considered a perfect hash
     */
    fpk/1


  /* Ephemeral AES key and IV creation */
  functions:
    /*
     * Arguments:
     *  - a nonce
     *  - another nonce
     * 
     * Output: a shared key
     */
    genKey/2,
    /*
     * Arguments:
     *  - a nonce
     *  - another nonce
     *
     * Output: yet another nonce
     */
    genIV/2


  /* Hashing of client secret nonce and authorization key */
  functions:
    /*
     * Arguments:
     *  - a nonce
     *  - an authorization key
     *
     * Outputs: the hash of the nonce and authorization key
     */
    hashNk/2
    
    

/*
 * MTProto 2.0: Encryption scheme - Part I (cloud chats)
 *
 * See: https://core.telegram.org/mtproto/description
 */
/*
 * MTProto 2.0: Creating an authorization key.
 *
 * Model for the protocol used to create long-term keys shared 
 * between a client and Telegram's server.
 *
 * See: https://core.telegram.org/mtproto/auth_key
 */

/*****************************************************************/
/* Decomposition into prime factors.                             */
/*                                                               */
/* This is used only for proof-of-work, a measure against DoS,   */
/* which we do not include in our threat model.                  */
/* This definition is reported here for the sake of              */
/* completeness, but it is never used.                           */
/*****************************************************************/

  functions:
    /*
     * Arguments:
     *  - a prime
     *  - another prime
     *
     * Outputs: their multiplication
     */
    multiply/2,
    /*
     * Arguments:
     *  - the multiplication of two primes
     *
     * Outputs: the two primes
     */
    factorise/1

  equations:
    factorise(multiply(x, y)) = <x, y>

/*****************************************************************/
/* Messages exchanged during the authorization protocol          */
/*****************************************************************/

/*
 * Two public constants are used: 'FIXED_NS' and 'WEAK_NK'.
 * 
 * Both represents nonces. The first one represents a constant 
 * nonce that may be used by the server, the second represents
 * a weak (leakable) nonce which is supposed to be kept
 * secret and its sent by the client to the server (encrypted).
 */


/*****************************************************************/
/* Protocol exchange definition                                  */
/*****************************************************************/

/* 1. C -> S: Nc */
  rule Client_1 [color=#E2C290]:
      [ 
        Fr(~nc),

        /* 
         * Following the eCK model, generate ephemeral 
         * secrets and save them for revealing them later. 
         */
        Fr(~nk),
        Fr(~c) 
      ]
    --[
        /* 
         * A client starts a run of the authorization protocol with 
         * the server proposing a random nonce ~nc.
         */
        ClientStartsSession(~nc)
      ]->
      [ 
        ClientState_1(~nc, ~nk, ~c), 
        Out(~nc),
        !AuthProtClientEphemeralSecrets(~nk, ~c) 
      ]

  /* 2. S -> C: Nc, Ns, fpk(pkey) */
  rule Server_2 [color=#0088CC]:
      [ In(nc), !PrivateKey($Server, skey), NS(ns), Fr(~s) ]
    --[
        /*
         * Server has received a request to start a 
         * run of the authorization protocol with client nonce nc.
         */
        ServerReceivesRequest(nc),

        /*
         * Captures information about the randomness of the 
         * server nonce.
         *
         * Lemmas using this fact are supposed to check whetever
         * the second term (actual nonce) is equal to 'FIXED_NS'
         * or not.
         */
        ServerGeneratesNonce(ns)
      ]->
      [ 
        Out(<nc, ns, fpk(pk(skey))>), 
        ServerState_2(nc, ns, skey, ~s), 
        !AuthProtServerEphemeralSecrets(~s) 
      ]


  /* 3. C -> S: Nc, Ns, aenc(Nc, Ns, Nk){pkey} */
  rule Client_3 [color=#E2C290]:
      [ 
        ClientState_1(~nc, ~nk, ~c),
        In(<~nc, ns, fingerprint>),
        !PublicKey($Server, pkey, fingerprint)
      ]
    --[
        /*
         * Client has obtained public key pkey corresponding
         * to the key fingerprint sent by server.
         */
        ClientGetsServerPublicKey(pkey),

        /*
         * Client requests DH parameters to server by 
         * sending a secret nonce nk in the session identified 
         * by <nc, ns>.
         */
        ClientRequestsDHParameters(~nc, ns, ~nk)
      ]->
      [ 
        ClientState_3(~nc, ns, ~nk, pkey, ~c),
        Out(<~nc, ns, aenc(<~nc, ns, ~nk>, pkey)>)
      ]

  /* 4. S -> C: Nc, Ns, senc(Nc, Ns, halfkey){key, iv} */
  rule Server_4 [color=#0088CC]:
    let
      half = 'g_auth' ^ ~s
      key  = genKey(ns, nk)
      iv   = genIV(ns, nk)
    in
      [
        ServerState_2(nc, ns, skey, ~s),
        In(aenc(<nc, ns, nk>, pk(skey)))
      ]
    --[
        /* 
         * Server has accepted a request to generate an
         * authorization key in session <nc, ns> for a client
         * who has sent a secret nonce nk.
         */
        ServerAcceptsClient(nc, ns, nk),

        /*
         * Server sends DH parameter 'g_auth' and its half-key
         * to a client who has started session <nc, ns> and sent
         * secret nonce nk.
         */
        ServerSendsDHParameters(nc, ns, nk, half)
      ]->
      [
        ServerState_4(nc, ns, nk, skey, ~s),
        Out(<nc, ns, senc(<'StoC', nc, ns, half>, key, iv)>)
      ]

  /* 5. C -> S: Nc, Ns, senc(Nc, Ns, halfkey){key, iv} */
  rule Client_5 [color=#E2C290]:
    let
      g_s        = 'g_auth' ^ ~s
      key  = genKey(ns, ~nk)
      iv   = genIV(ns, ~nk)
      half       = 'g_auth' ^ ~c
      authKey = g_s ^ ~c
    in
      [
        ClientState_3(~nc, ns, ~nk, pkey, ~c),
        In(<~nc, ns, senc(<'StoC', ~nc, ns, g_s>, key, iv)>)
      ]
    --[
        /*
         * Client has received DH paramters and the server's
         * half key g_s from server in the session identified by <nc, ns>
         * for which the client has generated secret nonce nk.
         */
        ClientReceivesDHParameters(~nc, ns, ~nk, g_s),

        /*
         * Client has accepted the DH parameter received 
         * from server in session <nc, ns> for which the client has
         * generated secret nonce nk and received the server's half
         * key g_s.
         */
        ClientAcceptsDHParameters(~nc, ns, ~nk, g_s),

        /*
         * Client completes the DH exchange with server in session 
         * <nc, ns> for which the client has generate the secret nonce 
         * nk and has received DH parameters <p, g> and half key g_s by 
         * computing the authorization key authKey and by sending its 
         * half key g_c to the server.
         */
        ClientEndsDHExchange(~nc, ns, ~nk, g_s, ~c, authKey),

        /*
         * Client has negotiated the authorization key authKey with
         * server in session <nc, ns>.
         */
        ClientAcceptsAuthKey(~nc, ns, ~nk, authKey)]->
      [
        ClientState_5(~nc, ns, ~nk, pkey, g_s, ~c, authKey),
        Out(<~nc, ns, senc(<'CtoS', ~nc, ns, half>, key, iv)>)
      ]


  /* 6. S -> C: Nc, Ns, hashNk(Nk, authKey) */
  rule Server_6 [color=#0088CC]:
    let
      g_c        = 'g_auth' ^ ~c
      key  = genKey(ns, nk)
      iv   = genIV(ns, nk)
      authKey = g_c ^ ~s
    in
      [ 
        ServerState_4(nc, ns, nk, skey, ~s), 
        In(<nc, ns, senc(<'CtoS', nc, ns, g_c>, key, iv)>) 
      ]
    --[ 
        /*
         * Server completes the DH exchange in session <nc, ns> 
         * for which a client has generated the secret nonce nk 
         * and the half key g_c by computing the authorization key authKey.
         */
        ServerEndsDHExchange(nc, ns, nk, g_c, authKey),

        /*
         * Server has negotiated the authorization key authKey with a 
         * client in session <nc, ns>.
         */
        ServerAcceptsAuthKey(nc, ns, nk, authKey),
      
        /*
         * Server sends an acknowledgment to a client in session 
         * <nc, ns> for which the client has generated secret nonce nk.
         */
        ServerSendsAck(nc, ns, nk, authKey)
      ]->
      [ 
        !AuthKeyServer(keyID(authKey), authKey), 
        Out(<nc, ns, hashNk(nk, authKey)>),
        !ServerEndsProtocol(nc, ns, nk, authKey, skey, ~s) 
      ]
  

  rule Client_7 [color=#E2C290]:
      [ 
        ClientState_5(~nc, ns, ~nk, pkey, g_s, ~c, authKey),
        In(<~nc, ns, hashNk(~nk, authKey)>)
      ]
    --[ 
        /*
         * Client X has received an acknowledgment from the server for
         * the authorization key negotiated in session <nc, ns>.
         */
        ClientReceivesAck(~nc, ns, ~nk, authKey)
      ]->
      [ 
        !AuthKeyClient($Server, authKey),
        !ClientEndsProtocol(~nc, ns, ~nk, authKey, ~c)
      ]
  

/*****************************************************************/
/* Key registration and Diffie Hellman parameters                */
/*****************************************************************/

  /* Register a public key for the server */
  rule RegisterPublicKey [color=#99C24D]:
    let
      pkey        = pk(~skey)
      fingerprint = fpk(pkey)
    in
      [ Fr(~skey) ]
    -->
      [ !PrivateKey($X, ~skey), !PublicKey($X, pkey, fingerprint), Out(pkey) ]
  
  rule GenerateRandomServerNonce [color=#99C24D]:
      [ Fr(~ns) ]
    -->
      [ NS(~ns) ]

  rule GenerateFixedServerNonce [color=#99C24D]:
      []
    -->
      [ NS('FIXED_NS') ]


/*****************************************************************/
/* Revealing of secret information                               */
/*****************************************************************/

  /* Compromise shared key. */
  rule CompromiseAuthKey [color=#FE4A49]:
      [ 
        !AuthKeyClient($Server, authKey),
        !AuthKeyServer(keyID(authKey), authKey)
      ]
    --[ CompromisedAuthKey(authKey) ]->
      [ Out(authKey) ]

  /* Reveals long-term secret of the server. */
  rule CompromisePrivateKey [color=#FE4A49]:
      [ !PrivateKey($Server, skey) ]
    --[ CompromisedPrivateKey(skey) ]->
      [ Out(skey) ]

  /* Reveals the secret client's nonce. */
  rule CompromiseNk [color=#FE4A49]:
      [ !AuthProtClientEphemeralSecrets(nk, b) ]
    --[ CompromisedNk(nk) ]->
      [ Out(nk) ]

  /* Reveals the client's DH secret exponent. */
  rule CompromiseAuthProtClientExponent [color=#FE4A49]:
      [ !AuthProtClientEphemeralSecrets(nk, c) ]
    --[ CompromisedClientExponent(c) ]->
      [ Out(c) ]

  /* Reveals all client's ephemeral secrets. */
  rule CompromiseClientEphemeralSecrets [color=#FE4A49]:
      [ !AuthProtClientEphemeralSecrets(nk, c) ]
    --[ CompromisedClientEphemeralSecrets(nk, c) ]->
      [ Out(<nk, c>) ]

  /* Reveals the client's DH secret exponent. */
  rule CompromiseAuthProtServerExponent [color=#FE4A49]:
      [ !AuthProtServerEphemeralSecrets(s) ]
    --[ CompromisedServerExponent(s) ]->
      [ Out(s) ]


/*****************************************************************/
/* Post-revealing of secret information                          */
/*****************************************************************/
//
//  /* 
//   * Reveals the private key of the server AFTER a 
//   * successful protocol execution.
//   */
//  rule PostCompromisePrivateKey [color=#FE4A49]:
//      [
//        !ClientEndsProtocol(nc, ns, nk, authKey, c),
//        !ServerEndsProtocol(nc, ns, nk, authKey, skey, s),
//        !PrivateKey($Server, skey)
//      ]
//    --[ PostCompromisedPrivateKey(skey) ]->
//      [ Out(skey) ]
//
//  
//  /* 
//   * Reveals the secret nonce nk AFTER a 
//   * successful protocol execution.
//   */
//  rule PostCompromiseNonce [color=#FE4A49]:
//      [
//        !ClientEndsProtocol(nc, ns, nk, authKey, c),
//        !ServerEndsProtocol(nc, ns, nk, authKey, skey, s)
//      ]
//    --[ PostCompromisedNonce(nk) ]->
//      [ Out(nk) ]
//
//
//  /* 
//   * Reveals the secret exponent of the client 
//   * AFTER a successful protocol execution.
//   */
//  rule PostCompromiseClientExponent [color=#FE4A49]:
//      [
//        !ClientEndsProtocol(nc, ns, nk, authKey, c),
//        !ServerEndsProtocol(nc, ns, nk, authKey, skey, s)
//      ]
//    --[ PostCompromisedClientExponent(c) ]->
//      [ Out(c) ]
//
//
//  /* 
//   * Reveals the secret exponent of the server 
//   * AFTER a successful protocol execution.
//   */
//  rule PostCompromiseServerExponent [color=#FE4A49]:
//      [
//        !ClientEndsProtocol(nc, ns, nk, authKey, c),
//        !ServerEndsProtocol(nc, ns, nk, authKey, skey, s)
//      ]
//    --[ PostCompromisedServerExponent(s) ]->
//      [ Out(s) ]
//

/*****************************************************************/
/* Helpers                                                       */
/*****************************************************************/

  /* 
   * These constants are used to distinguish client->server from
   * server->client messages.
   *
   * Public constants:
   *  - CLIENT
   *  - SERVER
   */
  
/*****************************************************************/
/* Protocol rules                                                */
/*****************************************************************/


  rule ClientCloudChat_1 [color=#E2C290]:
    let
      msg1 = <'CLIENT', ~sessionID, ~m1>
      mk1  = msgKey(authKey, msg1)
      c1   = senc(msg1, kdfKey(authKey, mk1), kdfIV(authKey, mk1))
    in
      [ 
        /* 
         * Retrieve the long-term shared key between client and server 
         */
        !AuthKeyClient($Server, authKey),

        /*
         * Telegram uses a random 64-bits number generated by the client
         * to distinguish between individual sessions. This is sent along
         * with the encrypted message.
         */
        Fr(~sessionID),
      
        /* 
         * Fresh message to be sent to the server.
         * This is supposed to remain secret. 
         */
        Fr(~m1)
      ]
    --[
        /*
         * The client has sent the cloud message ~m1 in session
         * with id ~sessionID and with authorization key authKey
         */
        ClientSendsCloudMessage(~sessionID, ~m1, authKey)
      ]->
      [ 
        ClientCloudChatState_1(<~sessionID, authKey, ~m1>),
        Out(<keyID(authKey), mk1, c1>)
      ]
  
  rule ServerCloudChat_2 [color=#0088CC]:
    let
      /* Pattern matching for the incoming message */
      mk1  = msgKey(authKey, msg1)
      msg1 = <'CLIENT', sessionID, m1>
      c1   = senc(msg1, kdfKey(authKey, mk1), kdfIV(authKey, mk1))

      /* Outgoing message creation */
      msg2 = <'SERVER', sessionID, ~m2>
      mk2  = msgKey(authKey, msg2)
      c2   = senc(msg2, kdfKey(authKey, mk2), kdfIV(authKey, mk2))
    in
      [ 
        In(<kID, mk1, c1>),

        /* Long-term key shared with the server */
        !AuthKeyServer(kID, authKey),

        /* 
         * Fresh message to be sent to the client. 
         * This is supposed to remain secret 
         */
        Fr(~m2)
      ]
    --[
        /*
         * Server has received the message m1 in session
         * sessionID using the authorization key authKey
         */
        ServerReceivesCloudMessage(sessionID, m1, authKey),

        /*
         * Server has sent the message ~m2 in session
         * sessionID using the authorization key authKey
         */
        ServerSendsCloudMessage(sessionID, ~m2, authKey)
      ]->
      [ 
        ServerCloudChatState_2(<sessionID, authKey, m1, ~m2>),
        Out(<keyID(authKey), mk2, c2>)
      ]

  
  rule ClientCloudChat_3 [color=#E2C290]:
    let
      kID  = keyID(authKey)
      
      /* Pattern matching for the incoming message */
      msg2 = <'SERVER', ~sessionID, m2>
      mk2  = msgKey(authKey, msg2)
      c2   = senc(msg2, kdfKey(authKey, mk2), kdfIV(authKey, mk2))
    in
      [ 
        ClientCloudChatState_1(<~sessionID, authKey, ~m1>),
        In(<kID, mk2, c2>)
      ]
    --[ 
        /*
         * Client has received the message m1 in session
         * sessionID using the authorization key authKey
         */
        ClientReceivesCloudMessage(~sessionID, m2, authKey)
      ]->
      [ ClientCloudChatState_3(<~sessionID, authKey, ~m1, m2>) ]


  /*
   * Key agreement: if client and server end up negotiating an authorization
   * key in a session executed correctly (and without revealing any secret),
   * then the key is the same.
   *
   * Note: here we're assuming that no secret (ephemeral or long-term) is
   * revealed. This assumption is captured by the last part of the formula.
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtAgreement:
    "
      /* Whenever a client and a server negotiate an authorization key */
      ∀ nc ns nk authKey1 authKey2 #i #j.
        (
          ServerAcceptsAuthKey(nc, ns, nk, authKey1) @i ∧
          ClientAcceptsAuthKey(nc, ns, nk, authKey2) @j ∧

          /* and no secret was leaked */
          ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        )
        ==>
        (
          /* then the authorization key is the same */
          ( authKey1 = authKey2 ) ∨
          
          /* 
           * or the server is actually running two different instances
           * of the protocol with the client
           */
          (
            ∃ #n1 #n2.
              ServerGeneratesNonce(ns) @n1 ∧
              ServerGeneratesNonce(ns) @n2 ∧
              ¬(#n1 = #n2)
          )
        )
    "

/*****************************************************************/
/* Broken agreement                                              */
/*****************************************************************/

  /*
   * Key agreement: if client and server end up negotiating an authorization
   * key in a session executed correctly, then the key is the same.
   *
   * In this session the server's private key is revealed. In this case
   * there is no guarantee (everything can be learned by the attacker).
   *
   * Expected result: False
   * Estimated time: ~20 seconds
   */
  lemma LemmaAuthProtBrokenAgreement_1:
    "

      ∀ nc ns nk1 nk2 authKey1 authKey2 #i #j.
        /* 
         * Whenever a client and a server have accepted an authKey 
         * in session <nc, ns>
         */
        ServerAcceptsAuthKey(nc, ns, nk1, authKey1) @i ∧
        ClientAcceptsAuthKey(nc, ns, nk2, authKey2) @j ∧
        
        /* and no secret was leaked but the secret key of the server */
          ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
          // ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        ==>
        (
          /* then client and server have computed the same authKey */
          (authKey1 = authKey2) ∨
         
          /* or the server re-used the server nonce */
          (
            ∃ #k1 #k2.
              ServerGeneratesNonce(ns) @k1 ∧
              ServerGeneratesNonce(ns) @k2 ∧
              ¬(#k1 = #k2)
          )
        )
    "

  /*
   * Key agreement: If client and server end up negotiating an authorization
   * key in a session executed correctly, then the key is the same.
   *
   * If the secret nonce nk is leaked, then the attacker can act as a MITM
   * on the DH exchange.

   * Expected result: False
   * Estimated time: ~30 seconds
   */
  lemma LemmaAuthProtBrokenAgreement_2:
    "

      ∀ nc ns nk1 nk2 authKey1 authKey2 #i #j.
        /* 
         * Whenever a client and a server have accepted an authKey 
         * in session <nc, ns>
         */
        ServerAcceptsAuthKey(nc, ns, nk1, authKey1) @i ∧
        ClientAcceptsAuthKey(nc, ns, nk2, authKey2) @j ∧
        
        /* and no secret was leaked but the secret nonce of the client */
          ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          // ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        ==>
        (
          /* then client and server have computed the same authKey */
          (authKey1 = authKey2) ∨
         
          /* or the server re-used the server nonce */
          (
            ∃ #k1 #k2.
              ServerGeneratesNonce(ns) @k1 ∧
              ServerGeneratesNonce(ns) @k2 ∧
              ¬(#k1 = #k2)
          )
        )
    "

  /*
   * Key agreement: If client and server end up negotiating an authorization
   * key in a session executed correctly, then the key is the same.
   *
   * If the DH exponents are revealed, the attacker can of course compute
   * the authorization key, but he cannot force the client and the server
   * to compute two different keys, nor he can act as a MITM. This means
   * that the key agreement actually holds (while secrecy will not).
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtBrokenAgreement_3:
    "
      ∀ nc ns nk1 nk2 authKey1 authKey2 #i #j.
        /* 
         * Whenever a client and a server have accepted an authKey 
         * in session <nc, ns>
         */
        ServerAcceptsAuthKey(nc, ns, nk1, authKey1) @i ∧
        ClientAcceptsAuthKey(nc, ns, nk2, authKey2) @j ∧
        
        /* and no secret was leaked but the secret DH exponents */
          ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          // ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r)
          // ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        ==>
        (
          /* 
           * then client and server have computed the same authKey
           */
          (authKey1 = authKey2) ∨
         
          /* or the server re-used the server nonce. */
          (
            ∃ #k1 #k2.
              ServerGeneratesNonce(ns) @k1 ∧
              ServerGeneratesNonce(ns) @k2 ∧
              ¬(#k1 = #k2)
          )
        )
    "/*****************************************************************/
/* Authentication client to server                               */
/*****************************************************************/

/*
 * There is no authentication of the client to the server. This is 
 * to be expected as the server is willing to run an instance of the 
 * protocol with anyone, including the attacker.
 *
 * Expected result: False
 * Estimated time: ~10 seconds
 */
  lemma LemmaAuthProtAuthClientToServer:
    "
      ∀ nc ns nk authKey #i #j.
        /* Whenever a client has started a session with nonce nc */
        ClientStartsSession(nc) @i ∧

        /* and the server has sent an ACK for the session <nc, ns> */
        ServerSendsAck(nc, ns, nk, authKey) @j ∧

        /* and no secret was leaked */          
        ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
        ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
        ¬(∃ n #r.    CompromisedNk(n) @r) ∧
        ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
        ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
        ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        ==>
        (
          /* then a client has shared an authKey with the server */
          (
            ∃ #k.
            ClientAcceptsAuthKey(nc, ns, nk, authKey) @k
          ) ∨

          /* 
           * or the server is actually running two different instances
           * of the protocol with the client
           */
          (
            ∃ #k #l.
              ServerGeneratesNonce(ns) @k ∧
              ServerGeneratesNonce(ns) @l ∧
              ¬(#k = #l)
          )
        )
    "

  /*
   * However, at the end of the authorization protocol the server knows
   * for sure that the client that has negotiated the authorization key authKey
   * is the client who sent the third message of the protocol.
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtAuthClientSentThirdMessage:
    "
      ∀ nc ns nk authKey #i #j.
        /* Whenever a client requested DH parameters in session <nc, ns> */
        ClientRequestsDHParameters(nc, ns, nk) @i ∧

        /* and the server ended the protocol correctly */
        ServerSendsAck(nc, ns, nk, authKey) @j ∧
        
        /* and no secret was leaked */
        ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
        ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
        ¬(∃ n #r.    CompromisedNk(n) @r) ∧
        ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
        ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
        ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        ==>
        (
          /* then the client has succesfully shared a key with the server */
          (
            ∃ #k.
            ClientAcceptsAuthKey(nc, ns, nk, authKey) @k
          ) ∨

          /* 
           * or the server is actually running two different instances
           * of the protocol with the client
           */
          (
            ∃ #k #l.
              ServerGeneratesNonce(ns) @k ∧
              ServerGeneratesNonce(ns) @l ∧
              ¬(#k = #l)
          )
        )
    "

/*****************************************************************/
/* Authentication server to client                               */
/*****************************************************************/


  /*
   * There is authentication of the server to the client (if the server
   * does not reuse its server nonce).
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtAuthServerToClient:
    "
      ∀ nc ns nk authKey #i.
        /* Whenever a client receives an ACK from the server */
        ClientReceivesAck(nc, ns, nk, authKey) @i ∧
        
        /* and no secret was leaked */
        ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
        ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
        ¬(∃ n #r.    CompromisedNk(n) @r) ∧
        ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
        ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
        ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        ==>
        (
          /* 
           * then there is a session matching it on the server
           *
           * Note: Trying to prove injectivity seems to make Tamarin use huge
           * amounts of RAM (~12-16 GB) in a very short period of time (~30/40 seconds).
           * Be careful if you uncomment the injectivity check.
           */
          ( 
            ∃ #j1.
            ServerAcceptsAuthKey(nc, ns, nk, authKey) @j1 
            // ∧
            // ¬(
            //   ∃ #j2.
            //     ServerAcceptsAuthKey(nc, ns, nk, authKey) @j2 ∧
            //     ¬(#j1 = #j2)
            // )
          ) ∨

          /* or the server has reused the same nonce */
          (
            ∃ #j1 #j2.
              ServerGeneratesNonce(ns) @j1 ∧
              ServerGeneratesNonce(ns) @j2 ∧
              ¬(#j1 = #j2)
          )
        )
    "

  /*
   * Secrecy of the key: if client and server end up negotiating the same key
   * but the attacker knows it, then some secret from that session was leaked.
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtKeySecrecy:
    "
      /* Whenever client and server shared a key and the attacker knows it */
      ∀ nc ns nk authKey #i #j #k.
        ClientAcceptsAuthKey(nc, ns, nk, authKey) @i ∧
        ServerAcceptsAuthKey(nc, nk, nk, authKey) @j ∧
        K(authKey) @k
        ==>
        /* then some secrects were leaked */
        (
          (∃ #r.      CompromisedAuthKey(authKey) @r) ∨
          (∃ skey #r. CompromisedPrivateKey(skey) @r) ∨
          (∃ #r.      CompromisedNk(nk) @r) ∨
          (∃ c #r.    CompromisedClientExponent(c) @r) ∨
          (∃ c #r.    CompromisedClientEphemeralSecrets(nk, c) @r) ∨
          (∃ s #r.    CompromisedServerExponent(s) @r)
        )

    "

  /*
   * If client and server end up accepting the same key, then 
   * they do so in the same session, unless something bad happens.
   *
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaAuthProtSession:
    "
      ∀ nc1 nc2 ns1 ns2 nk1 nk2 authKey #i #j.
        ClientAcceptsAuthKey(nc1, ns1, nk1, authKey) @i ∧
        ServerAcceptsAuthKey(nc2, ns2, nk2, authKey) @j
        ==>
        (
          (nc1 = nc2 ∧ ns1 = ns2 ∧ nk1 = nk2) ∨
          (∃ #r.      CompromisedAuthKey(authKey) @r) ∨
          (∃ skey #r. CompromisedPrivateKey(skey) @r) ∨
          (∃ #r.      CompromisedNk(nk1) @r) ∨
          (∃ #r.      CompromisedNk(nk2) @r) ∨
          (∃ c #r.    CompromisedClientExponent(c) @r) ∨
          (∃ c #r.    CompromisedClientEphemeralSecrets(nk1, c) @r) ∨
          (∃ c #r.    CompromisedClientEphemeralSecrets(nk2, c) @r) ∨
          (∃ s #r.    CompromisedServerExponent(s) @r)
        )
    "
/*****************************************************************/
/* Secrecy                                                       */
/*****************************************************************/

  /*
   * If the authorization key has been generated correctly and it is known only
   * to the client and the server, then cloud chats messages are secure against
   * attackers (the messages can be seen by the server, of course).
   */

  /*
   * Client -> Server
   * 
   * Expected result: True
   * Estimated time: ~2 minutes
   */
  lemma LemmaCloudChatSecrecyClientToServer:
    "
      ∀ sid msg authKey #i #j #r.
        (
          /* Whenever a client sends a cloud message to the server */
          ClientSendsCloudMessage(sid, msg, authKey) @i ∧

          /* and the server receives it */
          ServerReceivesCloudMessage(sid, msg, authKey) @j ∧

          /* and the attacker knows it */
          K(msg) @r ∧

          /* and no secret was leaked, but the authorization key authKey */
          // ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        )
        ==>
        (
          /* then the authorization key was actually compromised */
          (∃ #r.   CompromisedAuthKey(authKey) @r)
        )
    "


  /*
   * Client -> Server
   * 
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaCloudChatSecrecyServerToClient:
    "
      ∀ sid msg authKey #i #j #r.
        (
          /* Whenever a server sends a cloud message to the client */
          ServerSendsCloudMessage(sid, msg, authKey) @j ∧

          /* and the client receives it */
          ClientReceivesCloudMessage(sid, msg, authKey) @i ∧

          /* and the attacker knows it */
          K(msg) @r ∧
        
          /* and no secret was leaked, but the authorization key authKey */
          // ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        )
        ==>
        (
          /* then the authorization key was actually compromised */
          (∃ #r.   CompromisedAuthKey(authKey) @r)
        )
    "

/*****************************************************************/
/* Perfect Forward Secrecy                                       */
/*****************************************************************/
  
  /*
   * The secrecy of a message should be preserved for sessions 
   * that executed correctly even if some information is revealed 
   * after the session has complete ∞d (perfect forward secrecy).
   *
   * This query and the next one show that no PFS is guaranteed in cloud chats.
   */

  /*
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaCloudChatSecrecyClientToServerPFS:
    "
      ∀ nc ns nk sid msg authKey #i #j #m.
        (
          /* Whenever the client has accepted an authorization key */
          ClientAcceptsAuthKey(nc, ns, nk, authKey) @i ∧

          /* and the server has received a message with such key */
          ServerReceivesCloudMessage(sid, msg, authKey) @j ∧

          /* and the attacker knows the message */
          K(msg) @m ∧
        
          /* and no secret was leaked before the message was sent */
          ¬(∃ sk #r.   CompromisedAuthKey(sk) @r ∧ #r < #j) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r ∧ #r < #j) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r ∧ #r < #j) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r ∧ #r < #j) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧ // This is redundant, not considering it
          ¬(∃ s #r.    CompromisedServerExponent(s) @r ∧ #r < #j)
        )
        ==>
        (
          /* then there actually was a post-compromise of some secret */
          (∃ #r.      CompromisedAuthKey(authKey) @r ∧ #j < #r) ∨
          (∃ skey #r. CompromisedPrivateKey(skey) @r ∧ #j < #r) ∨
          (
            ∃ c #r1 #r2.
              CompromisedNk(nk) @r1 ∧
              CompromisedClientExponent(c) @r2 ∧
              #j < #r1 ∧
              #j < #r2
          ) ∨
          (
            ∃ s #r1 #r2.
              CompromisedNk(nk) @r1 ∧
              CompromisedServerExponent(s) @r2 ∧
              #j < #r1 ∧
              #j < #r2
          ) ∨
          (
            ∃ c s #r1 #r2.
              CompromisedClientExponent(c) @r1 ∧
              CompromisedServerExponent(s) @r2 ∧
              #j < #r1 ∧
              #j < #r2
          )
        )
    "

  /*
   * Expected result: True
   * Estimated time: ~10 seconds
   */
  lemma LemmaCloudChatSecrecyServerToClientPFS:
    "
      ∀ sid msg authKey #j #m.
        (
          /* Whenever the client has received a message */
          ClientReceivesCloudMessage(sid, msg, authKey) @j ∧

          /* and the attacker knows the message */
          K(msg) @m ∧
        
          /* and no secret was leaked before the message was sent */
          ¬(∃ sk #r.   CompromisedAuthKey(sk) @r ∧ #r < #j) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r ∧ #r < #j) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r ∧ #r < #j) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r ∧ #r < #j) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧ // This is redundant, not considering it
          ¬(∃ s #r.    CompromisedServerExponent(s) @r ∧ #r < #j)
        )
        ==>
        (
          /* then there actually was a post-compromise of some secret */
          (∃ #r.      CompromisedAuthKey(authKey) @r ∧ #j < #r) ∨
          (∃ skey #r. CompromisedPrivateKey(skey) @r ∧ #j < #r) ∨
          (
            ∃ nk c #r1 #r2.
              CompromisedNk(nk) @r1 ∧
              CompromisedClientExponent(c) @r2 ∧
              #j < #r1 ∧
              #j < #r2
          ) ∨
          (
            ∃ nk s #r1 #r2.
              CompromisedNk(nk) @r1 ∧
              CompromisedServerExponent(s) @r2 ∧
              #j < #r1 ∧
              #j < #r2
          ) ∨
          (
            ∃ c s #r1 #r2.
              CompromisedClientExponent(c) @r1 ∧
              CompromisedServerExponent(s) @r2 ∧
              #j < #r1 ∧
              #j < #r2
          )
        )
    "
/*****************************************************************/
/* Key Compromise Impersionation (Client)                        */
/*****************************************************************/

  /*
   * Under no leak of long-term or ephemeral secrets, if an honest client 
   * receives a message encrypted with key k then it was the
   * server who sent it, unless k was revealed by the attacker.
   *
   * This query shows thet key compromise impersonation is trivial: if an
   * authorization key leaks client-side, then the attacker can impersonate the
   * server to that client.
   *
   * Expected result: True
   * Estimated time: ~5 seconds
   */
  lemma LemmaCloudChatKCIClient:
    "
      ∀ sid1 msg authKey #i.
        (
          /* Whenever a client receives a cloud message from the server */
          ClientReceivesCloudMessage(sid1, msg, authKey) @i ∧

          /* and no secret was leaked, but the authorization key authKey */
          // ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        )
        ==>
        (
          /* 
           * then it was actually the server who sent the message
           *
           * Note: Trying to prove injectivity seems to make Tamarin use huge
           * amounts of RAM (~12-16 GB) in a very short period of time (~30/40 seconds).
           * Be careful if you uncomment the injectivity check.
           */
          (
            ∃ sid2 #j1. 
              ServerSendsCloudMessage(sid2, msg, authKey) @j1 ∧
              sid1 = sid2 
              // ∧
              // ¬(
              //   ∃ #j2.
              //     ServerSendsCloudMessage(sid2, msg, authKey) @j2 ∧
              //     ¬(#j1 = #j2)
              // )
          ) ∨
          
          /* or the authorization key was actually compromised */
          (∃ #r.   CompromisedAuthKey(authKey) @r)
        )
    "

/*****************************************************************/
/* Key Compromise Impersionation (Server)                        */
/*****************************************************************/

  /*
  * Under "normal circumstances" (no leak of long-term or ephemeral secrets),
  * if an honest client has negotiated key k with the server, and the server
  * receives a message encrypted with k, then it was that client who sent it,
  * unless k was revealed by the attacker.
  *
  * This query shows thet key compromise impersonation is trivial: if an
  * authorization key leaks server-side, then the attacker can impersonate the
  * corresponding client to the server.
  *
  * NOTE: in practice, MTProto2 protects against replay attacks with timestamps 
  * and counters (which are not modeled).
  *
  * Expected result: True
  * Estimated time: ~5 seconds
  */
  lemma LemmaCloudChatKCIServer:
    "
      ∀ nc ns nk sid msg authKey #i #j.
        (
          /* Whenever a client has accepted an authorization key */
          ClientAcceptsAuthKey(nc, ns, nk, authKey) @i ∧

          /* and the server has received a message using such key */
          ServerReceivesCloudMessage(sid, msg, authKey) @j ∧

          /* and no secret was leaked, but the authorization key authKey */
          // ¬(∃ sk #r.   CompromisedAuthKey(sk) @r) ∧
          ¬(∃ skey #r. CompromisedPrivateKey(skey) @r) ∧
          ¬(∃ n #r.    CompromisedNk(n) @r) ∧
          ¬(∃ c #r.    CompromisedClientExponent(c) @r) ∧
          ¬(∃ n c #r.  CompromisedClientEphemeralSecrets(n, c) @r) ∧
          ¬(∃ s #r.    CompromisedServerExponent(s) @r)
        )
        ==>
        (
          /* then it was actually the client who sent the message */
          (
            ∃ #j1. 
              ClientSendsCloudMessage(sid, msg, authKey) @j1
          ) ∨
          
          /* or the authorization key was actually compromised */
          (∃ #r. CompromisedAuthKey(authKey) @r)
        )
    "
end
